<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Potential Restraints · ProtoSyn.jl</title><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="ProtoSyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">ProtoSyn.jl</a></span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../../../getting-started/installation/">Installation</a></li><li><a class="tocitem" href="../../../../getting-started/first-steps/">First steps</a></li><li><a class="tocitem" href="../../../../getting-started/examples/">Examples</a></li></ul></li><li><span class="tocitem">ProtoSyn API</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-1-2" type="checkbox"/><label class="tocitem" for="menuitem-3-1-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../methods/graph/">Graph</a></li><li><a class="tocitem" href="../../methods/state/">State</a></li><li><a class="tocitem" href="../../methods/pose/">Pose</a></li><li><a class="tocitem" href="../../methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../methods/other/">Auxiliary methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1-3"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../calculators-section/">Calculators Section</a></li><li><a class="tocitem" href="../torchani/">TorchANI</a></li><li><a class="tocitem" href="../bond-distance-restraint/">Bond distance Restraint</a></li><li class="is-active"><a class="tocitem" href>Potential Restraints</a><ul class="internal"><li><a class="tocitem" href="#Base-methods"><span>Base methods</span></a></li><li><a class="tocitem" href="#Available-potentials"><span>Available potentials</span></a></li><li><a class="tocitem" href="#Creating-custom-potential-functions"><span>Creating custom potential functions</span></a></li><li><a class="tocitem" href="#Available-masks"><span>Available masks</span></a></li><li><a class="tocitem" href="#Creating-custom-masks"><span>Creating custom masks</span></a></li></ul></li><li><a class="tocitem" href="../electrostatics/">Electrostatics</a></li><li><a class="tocitem" href="../gb-solvation/">Generalized Born</a></li><li><a class="tocitem" href="../sasa/">SASA</a></li><li><a class="tocitem" href="../hydrogen-bonds/">Hydrogen Bonds</a></li><li><a class="tocitem" href="../radius-gyration/">Radius of gyration</a></li><li><a class="tocitem" href="../custom-ref-energy/">Custom reference energy</a></li><li><a class="tocitem" href="../ref15/">REF-15</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-4" type="checkbox"/><label class="tocitem" for="menuitem-3-1-4"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mutators/mutators-section/">Mutators Section</a></li><li><a class="tocitem" href="../../mutators/mutators-dihedral/">Dihedral Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-crankshaft/">Crankshaft Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-rigid-body/">Rigid Body Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-backrub/">Backrub Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-compound/">Compound Mutators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-5" type="checkbox"/><label class="tocitem" for="menuitem-3-1-5"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../drivers/drivers-section/">Drivers Section</a></li><li><a class="tocitem" href="../../drivers/drivers-monte-carlo/">Monte Carlo</a></li><li><a class="tocitem" href="../../drivers/drivers-steepest-descent/">Steepest Descent</a></li><li><a class="tocitem" href="../../drivers/drivers-ils/">ILS</a></li><li><a class="tocitem" href="../../drivers/drivers-compound/">Compound Driver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-6" type="checkbox"/><label class="tocitem" for="menuitem-3-1-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../submodules/external-packages/">External packages</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Peptides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../peptides/types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-2-3" type="checkbox"/><label class="tocitem" for="menuitem-3-2-3"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../../peptides/methods/graph/">Graph</a></li><li><a class="tocitem" href="../../../peptides/methods/state/">State</a></li><li><a class="tocitem" href="../../../peptides/methods/pose/">Pose</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-4" type="checkbox"/><label class="tocitem" for="menuitem-3-2-4"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/calculators/potential-restraints/">Potential Restraints</a></li><li><a class="tocitem" href="../../../peptides/calculators/electrostatics/">Electrostatics</a></li><li><a class="tocitem" href="../../../peptides/calculators/sasa/">SASA</a></li><li><a class="tocitem" href="../../../peptides/calculators/natural-frequency/">Natural frequency</a></li><li><a class="tocitem" href="../../../peptides/calculators/ss-propensity/">Secondary structure propensity</a></li><li><a class="tocitem" href="../../../peptides/calculators/caterpillar-solvation/">Caterpilar solvation model</a></li><li><a class="tocitem" href="../../../peptides/calculators/seqdes/">SeqDes model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-5" type="checkbox"/><label class="tocitem" for="menuitem-3-2-5"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/mutators/rotamer/">Rotamer Mutator</a></li><li><a class="tocitem" href="../../../peptides/mutators/design/">Design Mutator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-6" type="checkbox"/><label class="tocitem" for="menuitem-3-2-6"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/drivers/rotamer-blitz-driver/">Rotamer Blitz</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-7" type="checkbox"/><label class="tocitem" for="menuitem-3-2-7"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../../peptides/submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../../peptides/submodules/rotamers/">Rotamers</a></li><li><a class="tocitem" href="../../../peptides/submodules/external-packages/">External packages</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Materials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-3-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/methods/lattices/">Lattices</a></li><li><a class="tocitem" href="../../../materials/methods/carbons/">Carbons</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Sugars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/submodules/builder/">Builder</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../common/introduction/">Introduction</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ProtoSyn API</a></li><li><a class="is-disabled">Core</a></li><li><a class="is-disabled">Calculators</a></li><li class="is-active"><a href>Potential Restraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Potential Restraints</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/master/docs/src/protosyn-api/core/calculators/potential-restraints.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="calculators-potential-restraints"><a class="docs-heading-anchor" href="#calculators-potential-restraints">Potential restraints</a><a id="calculators-potential-restraints-1"></a><a class="docs-heading-anchor-permalink" href="#calculators-potential-restraints" title="Permalink"></a></h1><p><a href="#calculators-potential-restraints">Potential restraints</a> are a family of <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances that apply any given potential to a selection of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances, optionally further masked or mapped. In other words, the application of a potential restraint to a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> is characterized by a series of fully customizable steps to generate new and/or improved <a href="#calculators-potential-restraints">Potential restraints</a>:</p><ol><li>(Optional) Select a subset of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances to apply the potential;</li><li>Define the potential function to be applied (See <a href="#Available-potentials">Available potentials</a>);</li><li>Apply the potential mask to the selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances;</li><li>(Optional) Multiply a mask/map to the calculated energy and forces matrices;</li><li>Sum the calculated energy and forces matrices.</li></ol><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>Most of these <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances are specific for a certain type of molecules (such as <a href="../../../peptides/introduction/#Peptides">Peptides</a>). The following types and methods constitute the backbone for all <a href="#calculators-potential-restraints">Potential restraints</a>, but more specific applications can be found in other modules of ProtoSyn.</p></div></div><p><img src="../../../../assets/ProtoSyn-potential-restraint.png" alt="ProtoSyn Potential Restraint"/></p><p><strong>Figure 1 |</strong> A diagram representation of the application of a potential restraint, in ProtoSyn. A given potential function (See <a href="#Available-potentials">Available potentials</a>) is applied to a distance matrix (See <a href="../calculators-section/#Distance-matrix-calculation">Distance matrix calculation</a>) calculated from the distances between all selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances. The resulting 2D energy matrix includes the energy values for each pair of interacting <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances. An optional secondary output from the application of the potential function is a 3D forces matrix, with the forces felt on each atom from the interaction with its pair. Both these matrices can optionally suffer another step: the application of a mask or map. On one hand, a <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a>, similarly to its application in <code>AbstractSelection</code>s, turns <em>on</em> and <em>off</em> certain pairs of interacting atoms. As an example, a mask allows the user to ignore same-atom energy artifacts using a <a href="#ProtoSyn.Calculators.get_diagonal_mask"><code>get_diagonal_mask</code></a> or ignore interaction between atoms of the same residue using an <a href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>get_intra_residue_mask</code></a>. On the other hand, a map in a 2D matrix (with the same size as the 2D energy matrix) with weights and biases. When the two matrices are multiplied together, certain interaction strengths are increased while others are reduced. An example would be the application of a contact map, where each weight corresponds to the certainty factor for the distance between each of the considered <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> pairs. As a final step both the 2D energy matrix and the 3D forces matrix (optionally after the application of the mask/map) are summed (in both axis, in the case of energy calculation, and in one axis, in the case of forces calculation).</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>The above paradigm for application of potential restraints requires, for the correct calculation of forces, the <a href="../calculators-section/#ProtoSyn.Calculators.full_distance_matrix"><code>full_distance_matrix</code></a> to be considered. This causes the energy value calculated to be double the expected (not considering the application on any non diagonally symmetrical mask), as both the top and bottom triagonal matrices are considered. In most cases this is not an issue, as the energy values are compared between simulation frames in relation to eachother and therefore the scale of the value is not important. However, in specific applications, further adjustment of the potential and/or mask applied may be necessary.</p></div></div><p>The following section is subdivided in the following topics, for organizational purposes:</p><ul><li><a href="#Base-methods">Base methods</a></li><li><a href="#Available-potentials">Available potentials</a></li><li><a href="#Creating-custom-potential-functions">Creating custom potential functions</a></li><li><a href="#Available-masks">Available masks</a></li><li><a href="#Creating-custom-masks">Creating custom masks</a></li><li><a href="#Available-Potential-Restraint-EnergyFunctionComponents">Available Potential Restraint EnergyFunctionComponents</a></li></ul><h2 id="Base-methods"><a class="docs-heading-anchor" href="#Base-methods">Base methods</a><a id="Base-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Base-methods" title="Permalink"></a></h2><p>The following methods are ubiquous to all <a href="#calculators-potential-restraints">Potential restraints</a>:</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.apply_potential!" href="#ProtoSyn.Calculators.apply_potential!"><code>ProtoSyn.Calculators.apply_potential!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_potential!([A::Type{&lt;: ProtoSyn.AbstractAccelerationType}], pose::Pose, potential::Function, update_forces::Bool, [verlet_list::Union{VerletList, Nothing}], [selection::Union{Nothing, ProtoSyn.AbstractSelection}], [mask::MaskMap])</code></pre><p>Apply the given <code>potential</code> to the provided <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code>. If the <code>update_forces</code> flag is set to true, also calculate the forces acting on the system. The call to this function can be further customized by providing an optional <a href="../calculators-section/#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a>, an <code>AbstractSelection</code> <code>selection</code> or a <code>MaskMap</code> <code>map</code> (this can be a <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a>, a <code>Matrix</code> or a <code>Function</code>).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.apply_potential!(ProtoSyn.SISD_0, pose, (d; kwargs...) -&gt; 0.0, false, nothing, nothing, nothing)
(0.0, [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/potentials.jl#L27-L41">source</a></section></article><h2 id="Available-potentials"><a class="docs-heading-anchor" href="#Available-potentials">Available potentials</a><a id="Available-potentials-1"></a><a class="docs-heading-anchor-permalink" href="#Available-potentials" title="Permalink"></a></h2><p>A list of available potentials in ProtoSyn is described bellow. See <a href="#Creating-custom-potential-functions">Creating custom potential functions</a> for the required signature of new potential functions.</p><ul><li><a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a></li><li><a href="#ProtoSyn.Calculators.get_coulomb_potential"><code>get_coulomb_potential</code></a></li><li><a href="#ProtoSyn.Calculators.get_bump_potential"><code>get_bump_potential</code></a></li><li><a href="#ProtoSyn.Calculators.get_harmonic_potential"><code>get_harmonic_potential</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_flat_bottom_potential" href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>ProtoSyn.Calculators.get_flat_bottom_potential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_flat_bottom_potential(;d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf) where {T &lt;: AbstractFloat}</code></pre><p>Return a flat-bottom potential function, using the specified distances. The potential is made up of 5 different sectors, each with the following functions:</p><p class="math-container">\[f_{1}) \;\;\;\;\;\; e = m_{1} \cdot d + b_{1} \;\;\;\;\;\; \left \{ d &lt; d_{1} \right \}\,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[f_{2}) \;\;\;\;\;\; e = \left (d-d_{2}  \right )^{2} \;\;\;\;\;\;\;\; \left \{ d_{1} \leqslant d &lt; d_{2} \right \}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[f_{3}) \;\;\;\;\;\; e = 0 \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; \left \{ d_{2} \leqslant d \leqslant d_{3} \right \}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[f_{4}) \;\;\;\;\;\; e = \left (d-d_{3}  \right )^{2} \;\;\;\;\;\;\;\; \left \{ d_{4} &lt; d \leqslant d_{4} \right \}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[f_{5}) \;\;\;\;\;\; e = m_{2} \cdot d + b_{2} \;\;\;\;\;\;  \left \{ d &gt; d_{4} \right \}\,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p>Where </p><p class="math-container">\[m_{1} = 2 \left ( d_{1}-d_{2} \right ) \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[b_{1} = f_{2}\left ( d_{1} \right ) - m_{1} \cdot d_{1} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[m_{2} = 2\left ( d_{4} - d_{3} \right ) \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[b_{2} = f_{4}\left ( d_{4} \right ) - m_{2} \cdot d_{4} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p><em>The resulting function can be called with the following signature:</em></p><pre><code class="nohighlight hljs">flat_bottom_potential(d::T; v::Opt{Vector{T}} = nothing) where {T &lt;: AbstractFloat}</code></pre><p>Return an energy value based on the provided distance <code>d</code>. If a vector <code>v</code> is also provided (optional), the flat-bottom restraint will also return the forces <code>f1</code> and <code>f2</code> (the forces felt on both ends of the vector <code>v</code>). The vector <code>v</code> should have length = 3, corresponding to the 3 dimensions of the distance between the two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances (X, Y and Z). For more information on the flat-bottom potential, please read: <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4692055/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4692055/</a>. </p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> <a href="#ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint"><code>calc_flat_bottom_restraint</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = ProtoSyn.Calculators.get_flat_bottom_potential(d1 = 1.0, d2 = 2.0, d3 = 3.0, d4 = 4.0);

julia&gt; f(2.5)
0.0

julia&gt; f(1.73, v = (1.0, 1.0, 1.0))
(0.0729, (0.54, 0.54, 0.54), (-0.54, -0.54, -0.54))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/flat_bottom_potential.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_coulomb_potential" href="#ProtoSyn.Calculators.get_coulomb_potential"><code>ProtoSyn.Calculators.get_coulomb_potential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_coulomb_potential(d::T; v::Opt{Tuple{T, T, T}} = nothing, kwargs...) where {T &lt;: AbstractFloat}</code></pre><p>Return a simple coulomb potential with charges included, as described in https://www.softschools.com/formulas/physics/potential<em>energy</em>electrostatic<em>point</em>particles_formula/37/. The coulomb potential is measured between two charged point-like particles at distance <code>d</code> and charges <code>kwargs[:qi]</code> and <code>kwargs[:qj]</code>, respectivelly. If a vector <code>v</code> between the two particles is provided, also calculates the resulting forces.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.get_bump_potential"><code>get_bump_potential</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; coulomb = ProtoSyn.Calculators.get_coulomb_potential()

julia&gt; coulomb(2.0, qi = 1.0, qj = -1.0)
-0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/coulomb_potential.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_bump_potential" href="#ProtoSyn.Calculators.get_bump_potential"><code>ProtoSyn.Calculators.get_bump_potential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_bump_potential(;[c::T = 1.0], [r::T = 1.0]) where {T &lt;: AbstractFloat}</code></pre><p>Return a bump potential without charges included, as described in https://math.stackexchange.com/a/3236066. The bump function is centered around <code>c</code> with a radius <code>r</code>.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.get_bump_potential_charges"><code>get_bump_potential_charges</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.Calculators.get_bump_potential(c = 1.0, r = 1.0)
(::ProtoSyn.Calculators.var&quot;#bump_potential#25&quot;{ProtoSyn.Calculators.var&quot;#bump_potential#24#26&quot;{Float64, Float64, Float64}}) (generic function with 1 method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/bump_potential.jl#L49-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_bump_potential_charges" href="#ProtoSyn.Calculators.get_bump_potential_charges"><code>ProtoSyn.Calculators.get_bump_potential_charges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_bump_potential_charges(;[c::T = 1.0], [r::T = 1.0]) where {T &lt;: AbstractFloat}</code></pre><p>Return a bump potential with charges included, as described in https://math.stackexchange.com/a/3236066. The bump function is centered around <code>c</code> with a radius <code>r</code>.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.get_bump_potential"><code>get_bump_potential</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.Calculators.get_bump_potential_charges(c = 1.0, r = 1.0)
(::ProtoSyn.Calculators.var&quot;#bump_potential_charges#21&quot;{ProtoSyn.Calculators.var&quot;#bump_potential_charges#20#22&quot;{Float64, Float64}}) (generic function with 1 method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/bump_potential.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_harmonic_potential" href="#ProtoSyn.Calculators.get_harmonic_potential"><code>ProtoSyn.Calculators.get_harmonic_potential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_harmonic_potential(a::T, b::T, c::T) where {T &lt;: AbstractFloat}</code></pre><p>Return a simple harmonic potential with the following equation:</p><blockquote><p>U = ((d+a)²-b)*c</p></blockquote><p>The harmonic potential is measured between two point-like particles at distance <code>d</code> (doesn&#39;t take charges into consideration). If a vector <code>v</code> between the two particles is provided, also calculates the resulting forces.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.get_bump_potential"><code>get_bump_potential</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; harmonic = ProtoSyn.Calculators.get_harmonic_potential(1.0, 1.0, 1.0)

julia&gt; harmonic(1.0)
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/harmonic_potential.jl#L1-L22">source</a></section></article><p><img src="../../../../assets/ProtoSyn-potentials.png" alt="ProtoSyn Flat Bottom Potential"/></p><p><strong>Figure 1 |</strong> Visual depiction of the various potentials made available with ProtoSyn (version 1.1).</p><h2 id="Creating-custom-potential-functions"><a class="docs-heading-anchor" href="#Creating-custom-potential-functions">Creating custom potential functions</a><a id="Creating-custom-potential-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-custom-potential-functions" title="Permalink"></a></h2><p>Besides the currently <a href="#Available-potentials">Available potentials</a>, users can freely create custom and/or improved potential functions. In order to incorporate these potentials in <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances (and therefore in <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instances), the following signature must be followed.</p><pre><code class="language-julia hljs">energy, force1, force2 = new_potential(d::T; v::Opt{Tuple{T, T, T}} = nothing, kwargs...) where {T &lt;: AbstractFloat}</code></pre><p>Any function must, therefore, receive a distance value <code>d::T</code> between two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances and return the corresponding energy felt. Optionally, it may receive a vector <code>v::Vector{T}</code>, which is the difference vector between the two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> positions, in which case the potential should also return the two forces felt on each atom from this energetic interaction. The <code>kwargs</code> may contain extra information from the <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> function. Currently, only the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> charges are provided, with entries <code>qi</code> and <code>qj</code>. This may change in future versions of ProtoSyn.</p><p>The newly defined method can then be used in the <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> function: for each pair of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the <a href="../calculators-section/#ProtoSyn.Calculators.full_distance_matrix"><code>full_distance_matrix</code></a> this potential will be evaluated. The <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> (with the new potential) can then be used in a new <code>:calc</code> field of any new <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> (with the correct signature, see <a href="../calculators-section/#Creating-a-custom-EnergyFunctionComponent">Creating a custom EnergyFunctionComponent</a>). However, as a general rule of good practice, an extra step is usually included: as exemplified by the <a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a> method, the potential here is actually a <em>functor</em>, returned everytime the <a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a> function is called. A set of settings act as the input of this function (the settings of the encompassing <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a>), parametrizing the returned potential. Using this approach, the user has complete access to the <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a><code>.settings</code> field, which will dictate the parametrization of the newly developed potential. This can be useful, for example, in efforts to correctly parametrize an energetic contribution based on a set of data, as the used potential settings can be changed and optimized each step of the simulation, as a new potential is generated everytime. However, this generation should not negatively impact performance in any meaningfull way. </p><h2 id="Available-masks"><a class="docs-heading-anchor" href="#Available-masks">Available masks</a><a id="Available-masks-1"></a><a class="docs-heading-anchor-permalink" href="#Available-masks" title="Permalink"></a></h2><p>A list of available masks/maps in ProtoSyn is described bellow. See <a href="#Creating-custom-masks">Creating custom masks</a> for the required signature of new potential function masks/maps, and consider using <a href="#ProtoSyn.Calculators.show_available_masks"><code>ProtoSyn.Calculators.show_available_masks</code></a> method to list all available masks.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.show_available_masks" href="#ProtoSyn.Calculators.show_available_masks"><code>ProtoSyn.Calculators.show_available_masks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show_available_masks([io::IO], [m::Module])</code></pre><p>Prints all available masks for potential restraints Module m (defaults to <code>ProtoSyn.Calculators</code>) to the given <code>IO</code> <code>io</code> (defaults to <code>stdout</code>). Recursivelly searches any inner Module.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.show_available_masks()
+-------------------------------------------------------+
| Index | Mask function                                 |
+-------------------------------------------------------+
| 1     | get_bonded_mask                               |
| 2     | get_diagonal_mask                             |
+-------------------------------------------------------+
  └── Consider using the `?` menu to learn more about each mask function.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/mask_stage.jl#L109-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_intra_residue_mask" href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>ProtoSyn.Calculators.get_intra_residue_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_intra_residue_mask(pose::Pose, [selection::Opt{AbstractSelection}])</code></pre><p>For all the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the provided <code>AbstractSelection</code> <code>selection</code> (N), return a 2D N x N <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> with all the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances of the given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> not in the same residue selected. </p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This function is rather heavy and has low performance. If no design effort is being made (where the sequence changes), the resulting <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> from this function can and should be re-used (only calculated once). If, for a specific application, the <code>AbstractSelection</code> <code>selection</code> remains constant but the <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> needs to be re-calculated (for example, because there was a design/mutation step, use the <em>functor</em> resulting from <a href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>get_intra_residue_mask</code></a>).</p></div></div><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.show_available_masks"><code>show_available_masks</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.get_intra_residue_mask(pose, !an&quot;^CA$|^N$|^C$|^H$|^O$&quot;r)
ProtoSyn.Mask
 ├── Type: Atom
 ├── Size: (1140, 1140)
 ├── Count: 1279946 / 1299600
 └── Content: [0 0 … 1 1; 0 0 … 1 1; … ; 1 1 … 0 0; 1 1 … 0 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/mask_stage.jl#L144-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_bonded_mask" href="#ProtoSyn.Calculators.get_bonded_mask"><code>ProtoSyn.Calculators.get_bonded_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_bonded_mask(pose::Pose, [selection::Opt{AbstractSelection}])</code></pre><p>For all the atoms in the provided <code>AbstractSelection</code> <code>selection</code> (N), return a 2D N x N <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a>: for each <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance of the given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> mask out all other bonded <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.show_available_masks"><code>show_available_masks</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.get_bonded_mask(pose, an&quot;CA&quot;)
ProtoSyn.Mask
 ├── Type: Atom
 ├── Size: (73, 73)
 ├── Count: 5256 / 5329
 └── Content: [0 1 … 1 1; 1 0 … 1 1; … ; 1 1 … 0 1; 1 1 … 1 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/mask_stage.jl#L235-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_diagonal_mask" href="#ProtoSyn.Calculators.get_diagonal_mask"><code>ProtoSyn.Calculators.get_diagonal_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_diagonal_mask(pose::Pose, [selection::Opt{AbstractSelection}])</code></pre><p>For all the atoms in the provided <code>AbstractSelection</code> <code>selection</code> (N), return a 2D N x N <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> with all the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances of the given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> not in the natural diagonal selected (i.e. ignores same <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> interaction artifacts).</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.show_available_masks"><code>show_available_masks</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.get_diagonal_mask(pose, an&quot;CA&quot;)
ProtoSyn.Mask
 ├── Type: Atom
 ├── Size: (73, 73)
 ├── Count: 5256 / 5329
 └── Content: [0 1 … 1 1; 1 0 … 1 1; … ; 1 1 … 0 1; 1 1 … 1 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/mask_stage.jl#L199-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_upper_triangular_matrix_mask" href="#ProtoSyn.Calculators.get_upper_triangular_matrix_mask"><code>ProtoSyn.Calculators.get_upper_triangular_matrix_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_upper_triangular_matrix_mask(pose::Pose, [selection::Opt{AbstractSelection}])</code></pre><p>For all the atoms in the provided <code>AbstractSelection</code> <code>selection</code> (N), return a 2D N x N Matrix{T} with the bottom triangular matrix set to 0.0 (including diagonal) and upper triangular matrix set to 1.0.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.show_available_masks"><code>show_available_masks</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.get_upper_triangular_matrix_mask(pose, an&quot;CA&quot;)
73×73 Matrix{Float64}:
 (...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/mask_stage.jl#L282-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_upper_triangular_matrix_inversed_mask" href="#ProtoSyn.Calculators.get_upper_triangular_matrix_inversed_mask"><code>ProtoSyn.Calculators.get_upper_triangular_matrix_inversed_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_upper_triangular_matrix_mask(pose::Pose, [selection::Opt{AbstractSelection}])</code></pre><p>For all the atoms in the provided <code>AbstractSelection</code> <code>selection</code> (N), return a 2D N x N Matrix{T} with the bottom triangular matrix set to 0.0 (including diagonal) and upper triangular matrix set to -1.0.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.show_available_masks"><code>show_available_masks</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.get_upper_triangular_matrix_inversed_mask(pose, an&quot;CA&quot;)
73×73 Matrix{Float64}:
 (...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/mask_stage.jl#L320-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.load_map" href="#ProtoSyn.Calculators.load_map"><code>ProtoSyn.Calculators.load_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_map([::Type{T}], filename::String) where {T &lt;: AbstractFloat}</code></pre><p>Load the map in the <code>filename</code> file (i.e. Contact Map). The file should be in PFRMAT RR format (See: <a href="https://predictioncenter.org/casp13/index.cgi?page=format#RR">https://predictioncenter.org/casp13/index.cgi?page=format#RR</a>). Returns an N x N map of the found weights, with pairs not identified in the file set to 0.0 (N is the maximum indentifier found on the file. As an example, it might be the case where a peptide has 74 residues, but no pair with residue 74 is found on the file, the maximum identifier found might be 72, for example. In this case, the resulting map will have size 72 x 72. In order to ensure the loaded map size matches the underlying peptide size, consider adding an entry of 0.0 on the map file, with the correct maximum identifier). Note: If no optional type <code>T</code> is provided, will use <code>ProtoSyn.Units.defaultFloat</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; cmap = ProtoSyn.Calculators.load_map(&quot;contact_map_example.txt&quot;)
73×73 Array{Float64,2}:
 (...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/Potentials/mask_stage.jl#L358-L378">source</a></section></article><p><img src="../../../../assets/ProtoSyn-masks.png" alt="ProtoSyn Available Masks"/></p><p><strong>Figure 2 |</strong> Some of the available <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> instances in ProtoSyn. A <a href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>get_intra_residue_mask</code></a> de-selects all atoms that belong to the same <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instance (only accounting for inter-<a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> interactions). A <a href="#ProtoSyn.Calculators.get_diagonal_mask"><code>get_diagonal_mask</code></a> simply de-selects the same <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance in a 2D <a href="../calculators-section/#ProtoSyn.Calculators.full_distance_matrix"><code>full_distance_matrix</code></a>. Finally, a contact map is a loaded map (using the <a href="#ProtoSyn.Calculators.load_map"><code>load_map</code></a> method) that asserts a 2D Matrix of weights or biases to be multiplied by the resulting energy and forces matrices in <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a>. As an example, this can be the likelihood of two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances having a distance shorter can <code>D</code> Angstrom (Å).</p><h2 id="Creating-custom-masks"><a class="docs-heading-anchor" href="#Creating-custom-masks">Creating custom masks</a><a id="Creating-custom-masks-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-custom-masks" title="Permalink"></a></h2><p>In addition to the <a href="#Available-masks">Available masks</a>, users may wish to create and add custom <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> instances to employ in the <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> method. This method can receive a 2D <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> instance directly, as well as a <code>Matrix{T}</code> or a <code>Function</code> instance. Each case is discussed bellow:</p><ul><li><strong>2D <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a></strong> : A static mask, calculated only once. Energy and forces contributions will only be considered for the selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances (make sure the size of the <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> matches the number of selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> call). As an example, see <a href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>get_intra_residue_mask</code></a>. The syntax to create a new ProtoSyn <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> is as follows. For more details, see the <a href="../../submodules/selections/#Masks">Masks</a> section.</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2d_mask = Mask{Atom}(BitArray(falses(4, 4)))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: syntax: &quot;2&quot; is not a valid function argument name around REPL[1]:1</code></pre><ul><li><strong><span>$Matrix{T}$</span></strong> : A static map, calculated only once. Energy and forces contibutions will be multiplied by the <code>Matrix{T}</code> (make sure that the <code>Matrix{T}</code> size matches the number of selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> call). As an example, see <a href="#ProtoSyn.Calculators.load_map"><code>load_map</code></a>. The syntax to create a new <code>Matrix{T}</code> is as follows (as an example of a random map).</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2d_map = rand(4, 4)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: syntax: &quot;2&quot; is not a valid function argument name around REPL[1]:1</code></pre><ul><li><code>Function</code> : A dynamic mask or map, calculated every step/call of <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a>. This function should have the following simple signature, receiving a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> as input and returning either a <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> or a <code>Matrix{T}</code>.</li></ul><pre><code class="language-julia hljs">mask_or_map(pose::Pose)</code></pre><p>Altough potentially sacrificing the performance of the code, this allows for new <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> or a <code>Matrix{T}</code> instances to be calculated every step of a simulation, reflecting new changes, such as mutations or design efforts, for example.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>A common practice in building new <code>Function</code> instances that return <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> or a <code>Matrix{T}</code> instances for application in the <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> method is to encompass this <code>Function</code> as a <em>functor</em> of another <code>Function</code>. As an example, see the <a href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>get_intra_residue_mask</code></a> method. In this cases, the encompassing <code>Function</code> receives the <code>AbstractSelection</code> <code>selection</code>, making sure that the returned <code>Function</code> selects <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances only within this <code>selection</code>.</p></div></div><p>When a dynamic mask or map is used, performance penalties are to be expected. If a user whises to <strong>fixate</strong> a dynamic mask into a static mask (on the context of an <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> or <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>), the following companion methods are made available:</p><pre><code class="nohighlight hljs">ProtoSyn.Calculators.fixate_mask!
ProtoSyn.Calculators.fixate_masks!</code></pre><h3 id="Available-Potential-Restraint-EnergyFunctionComponents"><a class="docs-heading-anchor" href="#Available-Potential-Restraint-EnergyFunctionComponents">Available Potential Restraint EnergyFunctionComponents</a><a id="Available-Potential-Restraint-EnergyFunctionComponents-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Potential-Restraint-EnergyFunctionComponents" title="Permalink"></a></h3><p>Making use of all the above, the following default <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances are defined and made available:</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint" href="#ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint"><code>ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_flat_bottom_restraint([::Type{A}], pose::Pose, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, selection::Opt{AbstractSelection} = nothing, mask::MaskMap = nothing) where {A &lt;: ProtoSyn.AbstractAccelerationType, T &lt;: AbstractFloat}</code></pre><p>Apply a flat bottom potential to a given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code>. The potential is iteratively obtained each call using the <a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a> method (See <a href="#Available-potentials">Available potentials</a>), by providing the given <code>d1::T</code> (default: 0.0), <code>d2::T</code> (default = 0.0), <code>d3::T</code> (default = Inf) and <code>d4::T</code> (default = Inf) settings as the flat bottom potential distances. This potential then applied to the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> (via the <a href="#ProtoSyn.Calculators.apply_potential!"><code>apply_potential!</code></a> method), optionally on a subset of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances given by the <code>AbstractSelection</code> <code>selection</code> and optionally multiplied by a <code>mask</code>. This <code>mask</code> can be a <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a>, a <code>Matrix{T}</code> or a <code>Function</code>, in which case it should be a functor (return a <code>Function</code>) (For the correct signature of this <code>Function</code> <code>mask</code>, see <a href="#Creating-custom-masks">Creating custom masks</a>). These 3 options are named <code>MaskMap</code> for a simplicity of organization only. Return the total energy of the system and matrix of forces felt on each atom. Note that the calculation acceleration type can be set by providing an option parameter <code>A</code> <code>Type{&lt;: ProtoSyn.AbstractAccelerationType}</code>. If not provided, the default <code>ProtoSyn.acceleration.active</code> will be used instead.</p><pre><code class="nohighlight hljs">calc_flat_bottom_restraint!([::Type{A}], pose::Pose, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, selection::Opt{AbstractSelection} = nothing, mask::MaskMap = nothing) where {A &lt;: ProtoSyn.AbstractAccelerationType, T &lt;: AbstractFloat}</code></pre><p>Apply a flat bottom potential to a given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> (see above). Also apply any energy and forces changes directly to the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint(pose, true)
(0.0, [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])

julia&gt; ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint(pose, false, d1 = 10.0, d2 = 12.0)
(556449.1936070402, [-711.7603616347209 -630.2662235401388 … 995.0284325254745 1153.572133762037; -419.1275359380875 -548.0506257124055 … 286.5285847489888 92.16862928705675; 6.007398880372552 8.2409631821887 … -99.38257889245355 -92.37110004070036])    ```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/restraints.jl#L163-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.Restraints.get_default_all_atom_clash_restraint" href="#ProtoSyn.Calculators.Restraints.get_default_all_atom_clash_restraint"><code>ProtoSyn.Calculators.Restraints.get_default_all_atom_clash_restraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_default_all_atom_clash_restraint(;[α::T = 1.0]) where {T &lt;: AbstractFloat}</code></pre><p>Return the all-atom clash <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a>. <code>α</code> sets the component weight (on an <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instance). This component employs the <a href="#ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint"><code>calc_flat_bottom_restraint</code></a> method, therefore defining a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> energy based on a flat-bottom potential function applied to all atom-pairs in the system (N² complexity). By default, this <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> potential sets <code>:d1</code> and <code>:d2</code> of the flat-bottom potential to be 1.0 and 2.0, and masks out bonded atom-pairs.</p><p><strong>See also</strong></p><p><a href="../bond-distance-restraint/#ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint"><code>get_default_bond_distance_restraint</code></a></p><p><strong>Settings</strong></p><ul><li><code>d1::T</code> - The :d1 distance in the flat-bottom potential;</li><li><code>d2::T</code> - The :d2 distance in the flat-bottom potential;</li><li><code>d3::T</code> - The :d3 distance in the flat-bottom potential;</li><li><code>d4::T</code> - The :d4 distance in the flat-bottom potential;</li><li><code>mask::MaskMap</code> - The <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a>, <code>Matrix{T}</code> or <code>Function</code> (see <a href="#Creating-custom-masks">Creating custom masks</a>) that masks out our multiplied by a set of pre-defined <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances;</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.Calculators.Restraints.get_default_all_atom_clash_restraint()
🞧  Energy Function Component:
+---------------------------------------------------+
| Name           | All_Atom_Clash_Rest              |
| Alpha (α)      | 1.0                              |
| Update forces  | true                             |
| Calculator     | calc_flat_bottom_restraint       |
+---------------------------------------------------+
 |    +----------------------------------------------------------------------------------+
 ├──  ● Settings                      | Value                                            |
 |    +----------------------------------------------------------------------------------+
 |    | d4                            | Inf                                              |
 |    | d2                            | 2.0                                              |
 |    | mask                          | get_bonded_mask                                  |
 |    | d1                            | 1.0                                              |
 |    | d3                            | Inf                                              |
 |    +----------------------------------------------------------------------------------+
 |    
 └──  ○  Selection: nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/b5a50a0f2a0a2e5b8a72028e911f825be1f05a72/src/Core/Calculators/restraints.jl#L221-L265">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bond-distance-restraint/">« Bond distance Restraint</a><a class="docs-footer-nextpage" href="../electrostatics/">Electrostatics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 4 July 2022 16:16">Monday 4 July 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
