<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graph · ProtoSyn.jl</title><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="ProtoSyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">ProtoSyn.jl</a></span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../../../getting-started/installation/">Installation</a></li><li><a class="tocitem" href="../../../../getting-started/first-steps/">First steps</a></li><li><a class="tocitem" href="../../../../getting-started/examples/">Examples</a></li></ul></li><li><span class="tocitem">ProtoSyn API</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-1-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Graph</a><ul class="internal"><li><a class="tocitem" href="#Root-vs-Origin"><span>Root vs Origin</span></a></li><li><a class="tocitem" href="#Parenthood-relationships"><span>Parenthood relationships</span></a></li><li><a class="tocitem" href="#Container-manipulation"><span>Container manipulation</span></a></li><li><a class="tocitem" href="#core-graph-methods-indexation"><span>Indexation</span></a></li><li><a class="tocitem" href="#Counters-and-Iterators"><span>Counters and Iterators</span></a></li><li><a class="tocitem" href="#Bonds"><span>Bonds</span></a></li><li><a class="tocitem" href="#Travelling-the-Graph"><span>Travelling the Graph</span></a></li></ul></li><li><a class="tocitem" href="../state/">State</a></li><li><a class="tocitem" href="../pose/">Pose</a></li><li><a class="tocitem" href="../io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../other/">Auxiliary methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-3" type="checkbox"/><label class="tocitem" for="menuitem-3-1-3"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../calculators/calculators-section/">Calculators Section</a></li><li><a class="tocitem" href="../../calculators/torchani/">TorchANI</a></li><li><a class="tocitem" href="../../calculators/bond-distance-restraint/">Bond distance Restraint</a></li><li><a class="tocitem" href="../../calculators/potential-restraints/">Potential Restraints</a></li><li><a class="tocitem" href="../../calculators/electrostatics/">Electrostatics</a></li><li><a class="tocitem" href="../../calculators/gb-solvation/">Generalized Born</a></li><li><a class="tocitem" href="../../calculators/sasa/">SASA</a></li><li><a class="tocitem" href="../../calculators/hydrogen-bonds/">Hydrogen Bonds</a></li><li><a class="tocitem" href="../../calculators/radius-gyration/">Radius of gyration</a></li><li><a class="tocitem" href="../../calculators/custom-ref-energy/">Custom reference energy</a></li><li><a class="tocitem" href="../../calculators/ref15/">REF-15</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-4" type="checkbox"/><label class="tocitem" for="menuitem-3-1-4"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mutators/mutators-section/">Mutators Section</a></li><li><a class="tocitem" href="../../mutators/mutators-dihedral/">Dihedral Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-crankshaft/">Crankshaft Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-rigid-body/">Rigid Body Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-backrub/">Backrub Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-compound/">Compound Mutators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-5" type="checkbox"/><label class="tocitem" for="menuitem-3-1-5"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../drivers/drivers-section/">Drivers Section</a></li><li><a class="tocitem" href="../../drivers/drivers-monte-carlo/">Monte Carlo</a></li><li><a class="tocitem" href="../../drivers/drivers-steepest-descent/">Steepest Descent</a></li><li><a class="tocitem" href="../../drivers/drivers-ils/">ILS</a></li><li><a class="tocitem" href="../../drivers/drivers-compound/">Compound Driver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-6" type="checkbox"/><label class="tocitem" for="menuitem-3-1-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../submodules/external-packages/">External packages</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Peptides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../peptides/types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-2-3" type="checkbox"/><label class="tocitem" for="menuitem-3-2-3"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../../peptides/methods/graph/">Graph</a></li><li><a class="tocitem" href="../../../peptides/methods/state/">State</a></li><li><a class="tocitem" href="../../../peptides/methods/pose/">Pose</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-4" type="checkbox"/><label class="tocitem" for="menuitem-3-2-4"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/calculators/potential-restraints/">Potential Restraints</a></li><li><a class="tocitem" href="../../../peptides/calculators/electrostatics/">Electrostatics</a></li><li><a class="tocitem" href="../../../peptides/calculators/sasa/">SASA</a></li><li><a class="tocitem" href="../../../peptides/calculators/natural-frequency/">Natural frequency</a></li><li><a class="tocitem" href="../../../peptides/calculators/ss-propensity/">Secondary structure propensity</a></li><li><a class="tocitem" href="../../../peptides/calculators/caterpillar-solvation/">Caterpilar solvation model</a></li><li><a class="tocitem" href="../../../peptides/calculators/seqdes/">SeqDes model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-5" type="checkbox"/><label class="tocitem" for="menuitem-3-2-5"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/mutators/rotamer/">Rotamer Mutator</a></li><li><a class="tocitem" href="../../../peptides/mutators/design/">Design Mutator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-6" type="checkbox"/><label class="tocitem" for="menuitem-3-2-6"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/drivers/rotamer-blitz-driver/">Rotamer Blitz</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-7" type="checkbox"/><label class="tocitem" for="menuitem-3-2-7"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../../peptides/submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../../peptides/submodules/rotamers/">Rotamers</a></li><li><a class="tocitem" href="../../../peptides/submodules/external-packages/">External packages</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Materials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-3-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/methods/lattices/">Lattices</a></li><li><a class="tocitem" href="../../../materials/methods/carbons/">Carbons</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Sugars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/submodules/builder/">Builder</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../common/introduction/">Introduction</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ProtoSyn API</a></li><li><a class="is-disabled">Core</a></li><li><a class="is-disabled">Methods</a></li><li class="is-active"><a href>Graph</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Graph</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/master/docs/src/protosyn-api/core/methods/graph.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="core-graph-methods"><a class="docs-heading-anchor" href="#core-graph-methods">Graph</a><a id="core-graph-methods-1"></a><a class="docs-heading-anchor-permalink" href="#core-graph-methods" title="Permalink"></a></h1><p>This section lists functions that work on the system <a href="../../types/#state-types">Graph</a>, such as functions that deal with parent/child relations, indexes and bonds, among others. These are subdivided by topics, for organization purposes:</p><ul><li><a href="#Root-vs-Origin">Root vs Origin</a></li><li><a href="#Parenthood-relationships">Parenthood relationships</a></li><li><a href="#Container-manipulation">Container manipulation</a></li><li><a href="#core-graph-methods-indexation">Indexation</a></li><li><a href="#Counters-and-Iterators">Counters and Iterators</a></li><li><a href="#Bonds">Bonds</a></li><li><a href="#Travelling-the-Graph">Travelling the Graph</a></li></ul><h2 id="Root-vs-Origin"><a class="docs-heading-anchor" href="#Root-vs-Origin">Root vs Origin</a><a id="Root-vs-Origin-1"></a><a class="docs-heading-anchor-permalink" href="#Root-vs-Origin" title="Permalink"></a></h2><p>The <strong>root</strong> of a <a href="../../types/#state-types">Graph</a> is a set of 3 pseudoatoms belonging to a <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a>, acting as the anchor for internal coordinate calculations, while an <strong>origin</strong> is any <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance with no parent in any given container (for example, due to a cut). While a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> can only have 1 <strong>root</strong>, it can have multiple <strong>origins</strong> (which usually need to be reconnected for most of the simulations of ProtoSyn).</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.origin" href="#ProtoSyn.origin"><code>ProtoSyn.origin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">origin(container::AbstractContainer)</code></pre><p>Return the first <code>Atom</code> in <code>AbstractContainer</code> <code>container</code> that has no parent. The iteration follows the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance <code>:id</code> field, if correctly indexed. If no <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance without parent is found (i.e.: circular structures), return <code>nothing</code>. Note that the <a href="#ProtoSyn.root"><code>root</code></a> atoms are not considered. Note that if multiple origin <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances exists, this method return only the first found, based on the current <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> order in the given <code>AbstractContainer</code> <code>container</code>.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.root"><code>root</code></a> <a href="#ProtoSyn.reindex-Tuple{Topology}"><code>reindex</code></a> <a href="../pose/#ProtoSyn.sort_atoms_by_graph!"><code>sort_atoms_by_graph!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.root" href="#ProtoSyn.root"><code>ProtoSyn.root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">root(container::AbstractContainer)</code></pre><p>Return the first <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> of the Root of the <a href="../../types/#state-types">Graph</a> that given <code>AbstractContainer</code> <code>container</code> belongs to. If the given <code>AbstractContainer</code> <code>container</code> is not a <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> instance and has <code>:container</code> field set to <code>nothing</code>, return <code>nothing</code>.</p><pre><code class="nohighlight hljs">root(topology::Topology)</code></pre><p>Return the first <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> of the Root of the given <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> <code>topology</code> instance.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.origin"><code>origin</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L33-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Root" href="#ProtoSyn.Root"><code>ProtoSyn.Root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Root()::Residue</code></pre><p>Return a new Root residue. A Root residue in a pseudo-residue that serves the purpose of establishing an anchor for initial internal coordinates definition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; root = ProtoSyn.Root()
Residue{/ROOT:17124}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Types/graph.jl#L239-L250">source</a></section></article><h2 id="Parenthood-relationships"><a class="docs-heading-anchor" href="#Parenthood-relationships">Parenthood relationships</a><a id="Parenthood-relationships-1"></a><a class="docs-heading-anchor-permalink" href="#Parenthood-relationships" title="Permalink"></a></h2><p><a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> and <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances have parenthood relationships, in a directional <a href="../../types/#state-types">Graph</a>. Several methods allow the manipulation of such relationships, and are of additional importance when using internal coordinates to facilitate and speed up some calculations.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.hasparent" href="#ProtoSyn.hasparent"><code>ProtoSyn.hasparent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hasparent(c::AbstractContainer) -&gt; Bool</code></pre><p>Test whether the given AbstractContainer <code>c</code> has a parent.</p><p><strong>See Also</strong></p><p><a href="#ProtoSyn.isparent"><code>isparent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.isparent" href="#ProtoSyn.isparent"><code>ProtoSyn.isparent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isparent(parent::AbstractContainer, child::AbstractContainer)</code></pre><p>Test whether <code>parent</code> is the parent of <code>child</code>.</p><p><strong>See Also</strong></p><p><a href="#ProtoSyn.hasparent"><code>hasparent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L68-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.setparent!" href="#ProtoSyn.setparent!"><code>ProtoSyn.setparent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setparent!(child::T, parent::T) where {T &lt;: AbstractContainer}</code></pre><p>Set <code>parent</code> as the parent of <code>child</code>, while adding <code>child</code> to <code>parent.children</code>.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.popparent!"><code>popparent!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.popparent!" href="#ProtoSyn.popparent!"><code>ProtoSyn.popparent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">popparent!(child::AbstractContainer}</code></pre><p>Remove the parent from <code>child</code> (sets it to <code>nothing</code>) while removing <code>child</code> from <code>parent.children</code> (only if <code>child</code> is a child of <code>parent</code>).</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.setparent!"><code>setparent!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.ascendents" href="#ProtoSyn.ascendents"><code>ProtoSyn.ascendents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ascedents(container::AbstractContainer, level::Int)</code></pre><p>Return a <code>Tuple</code> containing the N (<code>level</code>) previous <code>:id</code> fields of the <code>:parent</code> <code>AbstractContainer</code> instances of the given <code>container</code> (recursivelly).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ascendents(pose.graph[1][1][4], 4)
(4, 3, 1, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L219-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.detach" href="#Base.detach"><code>Base.detach</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detach(segment::Segment)</code></pre><p>Detach and return the given <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> from it&#39;s container <a href="../../types/#state-types">Graph</a>, by:</p><ul><li>Detaching any <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> and <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instance from the <a href="../../types/#state-types">Graph</a>&#39;s Root (by popping parenthood relationships), if said instances belong to the given <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> instance.</li><li>Deleting this <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> from its container <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a>. </li></ul><p><em>This function is a Base module overload.</em></p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This function does not alter the <a href="../../types/#state-types">State</a> of the <a href="../../types/#pose-types">Pose</a> containing the provided <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a>. </p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; detach(pose.graph[1])
Segment{/UNK:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/base.jl#L459-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.is_contiguous" href="#ProtoSyn.is_contiguous"><code>ProtoSyn.is_contiguous</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_contiguous(pose::Pose, selection::AbstractSelection)</code></pre><p>Returns <code>true</code> if all the <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances gathered from the <code>selection</code> applied to the given <code>pose</code> are contiguous (have a parenthood relationship connecting them all). Note that the given <code>selection</code> is always promoted to <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> level.</p><p><strong>See also</strong></p><p><a href="../../../internals/#ProtoSyn.promote"><code>ProtoSyn.promote</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.is_contiguous(pose, rid&quot;1&quot; | rid&quot;3&quot;)
false

julia&gt; ProtoSyn.is_contiguous(pose, rid&quot;1:10&quot;)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L501-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.infer_parenthood!" href="#ProtoSyn.infer_parenthood!"><code>ProtoSyn.infer_parenthood!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">infer_parenthood!(container::ProtoSyn.AbstractContainer; overwrite::Bool = false, start::Opt{Atom} = nothing)</code></pre><p>Infers parenthood of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances on the given <code>AbstractContainer</code> <code>container</code>, from bond information, using a custom algorithm similar to breath first algorithm (atoms are sorted based on the size of the downstream graph and aromaticity). By default, the <a href="../../types/#graph-types">Graph</a> origin is set to the first <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance in the <code>container</code>. This behaviour can be controlled by setting a <code>start</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> as the origin of the new infered parenthood <a href="../../types/#graph-types">Graph</a>. If <code>overwrite</code> is set to <code>true</code> (<code>false</code>, by default), will overwrite existing pranthood information. After infering parenthood, if changes to the <a href="../../types/#graph-types">Graph</a> occurred, the existing internal coordinates match different cartesian coordinates. It&#39;s suggested to update internal coordinates (<a href="../state/#ProtoSyn.request_i2c!"><code>request_i2c!</code></a> &amp; <a href="../state/#ProtoSyn.sync!"><code>sync!</code></a>). For more details, see the <a href="#Travelling-the-Graph">Travelling the Graph</a> section. If the <code>linear_aromatics</code> flag is set to <code>true</code> (is, by default), aromatic rings are treated as isolated structures is an otherwise linear <a href="../../types/#graph-types">Graph</a> (for example, in some protein aminoacids). More complex structures (such as carbon sheets) have interlaced aromatic rings, and the <code>linear_aromatics</code> should be set to <code>false</code> to ensure all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances are visited.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.travel_bonds"><code>travel_bonds</code></a> <a href="#ProtoSyn.infer_bonds!"><code>infer_bonds!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.infer_parenthood!(pose.graph[1], overwrite = true)
Segment{/2a3d:8625/A:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L567-L597">source</a></section></article><p><img src="../../../../assets/ProtoSyn-graph2.png" alt="ProtoSyn graph"/></p><p><strong>Figure 1 |</strong> A diagram of a directional <a href="../../types/#state-types">Graph</a> in ProtoSyn.</p><h2 id="Container-manipulation"><a class="docs-heading-anchor" href="#Container-manipulation">Container manipulation</a><a id="Container-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Container-manipulation" title="Permalink"></a></h2><p><a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances have a <code>:container</code> field, setting the container <code>AbstractContainer</code> (usually a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instance). The same logic applies to <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances, inside <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> structs, and <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> instances inside <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> structs (according to the established hierarchy of <code>AbstractContainer</code> instances). The following methods allow for the correct manipulation of this relations, allowing to add and remove <code>AbstractContainer</code> instances from the respective <code>:container</code> field, as well as creating copies of them.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.hascontainer" href="#ProtoSyn.hascontainer"><code>ProtoSyn.hascontainer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hascontainer(c::AbstractContainer)</code></pre><p>Return <code>true</code> if the given <code>AbstractContainer.container</code> is not <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer" href="#Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">push!(container::AbstractContainer{T}, item::T) where {T &lt;: AbstractContainer}</code></pre><p>Add an <code>AbstractContainer</code> <code>item</code> to the <code>AbstractContainer</code> <code>container</code>, updating the <code>container</code> size and setting the correct <code>item.container</code>. Return the altered <code>container</code>.</p><pre><code class="nohighlight hljs">push!(residue::Residue, atom::Atom)</code></pre><p>In the specific case of adding an <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> to a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>residue</code>, also add the <code>atom.name</code> to the <code>residue.itemsbyname</code> dictionary for correct indexation by name. Return the altered <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>residue</code>.</p><pre><code class="nohighlight hljs">push!(container::AbstractContainer{T}, items::Vector{T}) where {T &lt;: AbstractContainer}</code></pre><p>Add a vector of <code>AbstractContainer</code> <code>items</code> in the <code>AbstractContainer</code> <code>container</code>, updating the <code>container</code> size and setting the correct <code>item.container</code> for each item in the <code>items</code>. Note that this method keeps the order of <code>items</code>. Return the altered <code>container</code>.</p><p><em>This function is a Base module overload.</em></p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This function does not set any <a href="#Bonds">Bonds</a> or <a href="#Parenthood-relationships">Parenthood relationships</a> to other items in the same <code>container</code>. This function does not set a complementary <a href="../../types/#state-types">State</a>.</p></div></div><p><strong>See also</strong></p><p><a href="#Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>insert!</code></a> <a href="#Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>delete!</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; push!(pose.graph[1][1], Atom(&quot;CA&quot;, -1, -1, &quot;C&quot;))
Residue{/UNK:1/UNK:1/SER:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/base.jl#L37-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T&lt;:ProtoSyn.AbstractContainer" href="#Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert!(container::AbstractContainer{T}, index::Integer, item::T) where {T &lt;: AbstractContainer}</code></pre><p>Insert an <code>AbstractContainer</code> <code>item</code> in the <code>AbstractContainer</code> <code>container</code> at the given <code>index</code>, updating the <code>container</code> size and setting the correct <code>item.container</code>. Return the altered <code>container</code>.</p><pre><code class="nohighlight hljs">insert!(container::Residue, index::Integer, item::Atom)</code></pre><p>In the specific case of inserting an <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> in a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>residue</code>, also add the <code>atom.name</code> to the <code>residue.itemsbyname</code> dictionary for correct indexation by name. Return the altered <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>residue</code>.</p><pre><code class="nohighlight hljs">insert!(container::AbstractContainer{T}, index::Integer, items::Vector{T}) where {T &lt;: AbstractContainer}</code></pre><p>Insert a vector of <code>AbstractContainer</code> <code>items</code> in the <code>AbstractContainer</code> <code>container</code> at the given <code>index</code>, updating the <code>container</code> size and setting the correct <code>item.container</code> for each item in the <code>items</code>. Note that this method keeps the order of <code>items</code>. Return the altered <code>container</code>.</p><p><em>This function is a Base module overload.</em></p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This function does not set any <a href="#Bonds">Bonds</a> or <a href="#Parenthood-relationships">Parenthood relationships</a> to other items in the same <code>container</code>. This function does not set a complementary <a href="../../types/#state-types">State</a>.</p></div></div><p><strong>See also</strong></p><p><a href="#Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>push!</code></a> <a href="#Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>delete!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; insert!(pose.graph[1][1], 3, Atom(&quot;CA&quot;, -1, -1, &quot;C&quot;))
Residue{/UNK:1/UNK:1/SER:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/base.jl#L101-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer" href="#Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete!(container::AbstractContainer{T}, item::T) where {T &lt;: AbstractContainer}</code></pre><p>Delete the given <code>AbstractContainer</code> <code>item</code> from the <code>AbstractContainer</code> <code>container</code>, if found, while updating the <code>container.size</code> and <code>item.container</code> fields. In the specific case of deleting an <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance from a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a>, update <code>container.itemsbyname</code> as well. Return the altered <code>container</code>. If the given <code>AbstractContainer</code> <code>item</code> is not found in the <code>AbstractContainer</code> <code>container</code>, return <code>nothing</code>.</p><p><strong>See also</strong></p><p><a href="#Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>push!</code></a> <a href="#Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>insert!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; delete!(pose.graph[1][1], pose.graph[1][1][&quot;CA&quot;])
Residue{/UNK:1/UNK:1/SER:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/base.jl#L397-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{Atom}" href="#Base.copy-Tuple{Atom}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(container::AbstractContainer)</code></pre><p>Return a copy of the given <code>AbstractContainer</code> <code>container</code>. Note that for <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances only the intra-residue <a href="#Bonds">Bonds</a> and <a href="#Parenthood-relationships">Parenthood relationships</a> can be copied. The same logic applies to the intra-segment <a href="../../types/#graph-types">Graph</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; copy(pose.graph[1, 1, 1])
Atom{/N:1}

julia&gt; copy(pose.graph[1, 1])
Residue{/SER:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/base.jl#L212-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.rename!" href="#ProtoSyn.rename!"><code>ProtoSyn.rename!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rename!(atom::Atom, name::String; force_rename::Bool = false)</code></pre><p>Rename the selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance to the given <code>name</code>. Also updates the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> container <code>:itemsbyname</code> field. If <code>force_rename</code> is set to <code>true</code> (<code>false</code>, by default), will change existing <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances with the same <code>name</code> trying to be introduced to adopt a temporary name (current name with &quot;_o&quot; appendix).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.rename!(pose.graph[1][1][&quot;N&quot;], &quot;N1&quot;)
Atom{/2a3d:51894/A:1/MET:1/N1:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L241-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Atom!" href="#ProtoSyn.Atom!"><code>ProtoSyn.Atom!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Atom!(r::Residue, name::String, id::Int, index::Int, symbol::String)</code></pre><p>Create a new <code>Atom</code> (with the given <code>name</code>, <code>id</code>, <code>index</code> and <code>symbol</code>) and add it to the given Residue <code>residue</code>. Returns the created <code>Atom</code> instance.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; atom = Atom!(pose.graph[1][1], &quot;H1&quot;, 1, 1, &quot;H&quot;)
Atom{/UNK:1/UNK:1/SER:1/H1:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Types/graph.jl#L307-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Residue!" href="#ProtoSyn.Residue!"><code>ProtoSyn.Residue!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Residue!(segment::Segment, name::String, id::Int)::Residue</code></pre><p>Create a new <code>Residue</code> (with the given <code>name</code> and <code>id</code>) and add it to the given Segment <code>segment</code>. Returns the created <code>Residue</code> instance.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; res = Residue!(pose.graph[1], &quot;ALA&quot;, 1)
Residue{/UNK:1/UNK:1/ALA:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Types/graph.jl#L284-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Segment!" href="#ProtoSyn.Segment!"><code>ProtoSyn.Segment!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Segment!(topology::Topology, name::String, id::Int)::Residue</code></pre><p>Create a new <code>Segment</code> (with the given <code>name</code> and <code>id</code>) and add it to the given Topology <code>topology</code>. Returns the created <code>Segment</code> instance.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; seg = Segment!(pose.graph, &quot;UNK&quot;, 1)
Segment{/UNK:1/UNK:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Types/graph.jl#L265-L276">source</a></section></article><h2 id="core-graph-methods-indexation"><a class="docs-heading-anchor" href="#core-graph-methods-indexation">Indexation</a><a id="core-graph-methods-indexation-1"></a><a class="docs-heading-anchor-permalink" href="#core-graph-methods-indexation" title="Permalink"></a></h2><p>An important initial detail when describing the <a href="#core-graph-methods">Graph</a> methods is describing the family of <code>getindex</code> methods overloaded by ProtoSyn when dealing with <a href="../../types/#graph-types">Graph</a> structures. There is, in essence, 4 ways to access a specific instance in the <a href="../../types/#graph-types">Graph</a>:</p><ul><li>Using the regular syntax;</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pose.graph.items[1].items[1].items[1]</code><code class="nohighlight hljs ansi" style="display:block;">Atom{/UNK:1/UNK:1/GLY:1/N:1}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pose.graph.items[1].items[1]</code><code class="nohighlight hljs ansi" style="display:block;">Residue{/UNK:1/UNK:1/GLY:1}</code></pre><ul><li>Using the short syntax with index;</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pose.graph[1][1][1]</code><code class="nohighlight hljs ansi" style="display:block;">Atom{/UNK:1/UNK:1/GLY:1/N:1}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pose.graph[1][1]</code><code class="nohighlight hljs ansi" style="display:block;">Residue{/UNK:1/UNK:1/GLY:1}</code></pre><ul><li>Using the condensed syntax with index;</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pose.graph[1, 1, 1]</code><code class="nohighlight hljs ansi" style="display:block;">Atom{/UNK:1/UNK:1/GLY:1/N:1}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pose.graph[1, 1]</code><code class="nohighlight hljs ansi" style="display:block;">Residue{/UNK:1/UNK:1/GLY:1}</code></pre><ul><li>Using the short or condensed syntax with atom name (for <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances only).</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pose.graph[1][1][&quot;N&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">Atom{/UNK:1/UNK:1/GLY:1/N:1}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pose.graph[1, 1, &quot;N&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">Atom{/UNK:1/UNK:1/GLY:1/N:1}</code></pre><p>Note that queries by <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.name</code> are case sensitive. Besides using it to get <a href="../../types/#graph-types">Graph</a> structures, <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.name</code> fields can also be used to query for existence:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; &quot;N&quot; in pose.graph[1][1]</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>The following methods deal with the correct indexation of the <a href="../../types/#state-types">Graph</a>. Note that, altough not necessary, some simulation functions assume that both the <a href="../../types/#state-types">Graph</a> and <a href="../../types/#state-types">State</a> indexation of a <a href="../../types/#pose-types">Pose</a> are synched and are equal.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.genid" href="#ProtoSyn.genid"><code>ProtoSyn.genid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genid()</code></pre><p>Return a random <code>UInt16</code> number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.reindex-Tuple{Topology}" href="#ProtoSyn.reindex-Tuple{Topology}"><code>ProtoSyn.reindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reindex(topology::Topology; set_ascendents = true)</code></pre><p>Re-indexes the whole <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> <code>topology</code>, setting both the <code>:id</code> and <code>:index</code> of instances inside the <code>topology</code> to the corresponding relative index in the <code>container.items</code> which they belong to. If <code>set_ascendents</code> is set to <code>true</code> (is, by default), each <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance <code>:ascendents</code> field will be updated to reflect the new indices.</p><pre><code class="nohighlight hljs">reindex(segment::Segment)</code></pre><p>Re-indexes a <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> <code>segment</code>, setting both the <code>:id</code> and <code>:index</code> of instances inside the <code>topology</code> to the corresponding relative index in the <code>container.items</code> which they belong to.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.ascendents"><code>ascendents</code></a> <a href="../state/#ProtoSyn.reindex-Tuple{State}"><code>reindex(::State)</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reindex(pose.graph)
Topology{/UNK:1}

julia&gt; reindex(pose.graph[1])
Segment{/UNK:1/UNK:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L149-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.ids" href="#ProtoSyn.ids"><code>ProtoSyn.ids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ids(atoms::Vector{Atom})</code></pre><p>Return a vector with the <code>:id</code> <code>Int</code> field for every <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> in the given <code>atoms</code> vector.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.travel_graph"><code>travel_graph</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.ids(an&quot;CA&quot;(pose, gather = true))
21-element Vector{Int64}:
   3
  14
  29
  40
  55
  65
   ⋮
 243
 257
 281
 300
 317
 327</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L464-L491">source</a></section></article><h2 id="Counters-and-Iterators"><a class="docs-heading-anchor" href="#Counters-and-Iterators">Counters and Iterators</a><a id="Counters-and-Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Counters-and-Iterators" title="Permalink"></a></h2><p>ProtoSyn includes custom <a href="#Counters-and-Iterators">Counters and Iterators</a> to analyze and loop over <a href="../../types/#graph-types">Graph</a> structures. In one hand, by using Counters the user can count the number of sub <code>AbstractContainer</code> instances in a <a href="../../types/#graph-types">Graph</a> component (for example, the number of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in a <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> or a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a>). This can be achieved by using the <code>count_atoms</code>, <code>count_residues</code> and <code>count_segments</code> methods.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ProtoSyn.count_atoms(pose.graph)</code><code class="nohighlight hljs ansi" style="display:block;">39</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ProtoSyn.count_atoms(pose.graph[1][1])</code><code class="nohighlight hljs ansi" style="display:block;">7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ProtoSyn.count_residues(pose.graph)</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><p>On the other hand, Iterators allow the user to iterate over all sub <code>AbstractContainer</code> instances in a <a href="../../types/#graph-types">Graph</a> component, by using the <code>eachatom</code>, <code>eachresidue</code> and <code>eachsegment</code> methods.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; eachatom(pose.graph)</code><code class="nohighlight hljs ansi" style="display:block;">ItemIterator{Topology, _ByAtom} with size (1, 3, 39)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for residue in eachresidue(pose.graph[1])
           println(residue);
       end</code><code class="nohighlight hljs ansi" style="display:block;">Residue{/UNK:1/UNK:1/GLY:1}
Residue{/UNK:1/UNK:1/MET:2}
Residue{/UNK:1/UNK:1/GLU:3}</code></pre><p>For <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances in specific, a more direct way to list all instances in a given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> or <code>AbstractContainer</code> is to use the <a href="#ProtoSyn.sequence"><code>sequence</code></a> method.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.sequence" href="#ProtoSyn.sequence"><code>ProtoSyn.sequence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sequence(container::ProtoSyn.AbstractContainer)::String
sequence(pose::Pose)::String</code></pre><p>Return the sequence of residues (in 1 letter code) of the given container/ <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> as a String. Checks the <code>ProtoSyn.three_2_one</code> dictionary for name to 1 letter code translation, uses &#39;?&#39; if no entry was found.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Peptides.sequence(pose)
&quot;SESEAEFKQRLAAIKTRLQAL&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L856-L870">source</a></section></article><h2 id="Bonds"><a class="docs-heading-anchor" href="#Bonds">Bonds</a><a id="Bonds-1"></a><a class="docs-heading-anchor-permalink" href="#Bonds" title="Permalink"></a></h2><p>The following methods deal with the bonding/unbonding of atoms (and respective <a href="#Parenthood-relationships">Parenthood relationships</a> when using the <a href="#ProtoSyn.join"><code>join</code></a> function).</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.bond" href="#ProtoSyn.bond"><code>ProtoSyn.bond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bond(at1::Atom, at2::Atom)</code></pre><p>Bond both given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances (adds <code>at2</code> to <code>at1.bonds</code> and vice-versa). Both <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances need to be in the same <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a>.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.join"><code>join</code></a> <a href="#ProtoSyn.unbond!"><code>unbond!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.bond(pose.graph[1][1][&quot;C&quot;], pose.graph[1][2][&quot;CA&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L381-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.unbond!" href="#ProtoSyn.unbond!"><code>ProtoSyn.unbond!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unbond!(pose::Pose, at1::Atom, at2::Atom; [keep_downstream_position::Bool = true])::Pose</code></pre><p>Return a <a href="../../types/#pose-types">Pose</a> instance with both given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances unbonded (removed from eachother <code>bonds</code> list, pops parenthood and sets the downstream <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a><code>.parent</code> field to be the Root of the upstream <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a>). If <code>keep_downstream_position</code> is set to <code>true</code> (is, by default), the downstream <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> position is maintained (by calling <a href="../state/#ProtoSyn.request_c2i!"><code>request_c2i!</code></a> and <a href="../state/#ProtoSyn.sync!"><code>sync!</code></a> methods). </p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>Unbonding two atoms also removes any parenthood relationship, therefore making the returned <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> from this function un-usable without further changes (the internal coordinates graph is severed on the unbonding site).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unbond!(pose, pose.graph[1][2][&quot;C&quot;], pose.graph[1][3][&quot;N&quot;])
Pose{Topology}(Topology{/UNK:1}, State{Float64}:
 Size: 343
 i2c: true | c2i: false
 Energy: Dict(:Total =&gt; Inf)
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L283-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.join" href="#ProtoSyn.join"><code>ProtoSyn.join</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">join(at1::Atom, at2::Atom)</code></pre><p>Join <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>at1</code> with <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>at2</code>.</p><pre><code class="nohighlight hljs">join(r1::Residue, s1::String, r2::Residue, s2::String)</code></pre><p>Join <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> named <code>s1</code> from <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>r1</code> with <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> named <code>s2</code> from <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>r2</code>.</p><p>Bond (add eachother to <code>other.bonds</code> field) and set parent/children relationship of both the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances and respective <code>atom.container</code> (<a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a>). Note that <code>at2</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> will become parent at <code>at1</code> (and <code>at2.container</code> <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> will become parent of <code>at1.container</code>).</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.bond"><code>bond</code></a> <a href="#ProtoSyn.unbond!"><code>unbond!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Residue!(pose.graph[1], ProtoSyn.ResidueName(&quot;ALA&quot;), 1);

julia&gt; Atom!(pose.graph[1][end], &quot;N&quot;, 1, 1, &quot;N&quot;);

julia&gt; ProtoSyn.join(pose.graph[1][1], &quot;C&quot;, pose.graph[1][end], &quot;N&quot;)
Residue{/UNK:1/UNK:1/ALA:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L405-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.infer_bonds!" href="#ProtoSyn.infer_bonds!"><code>ProtoSyn.infer_bonds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">infer_bonds!(pose::Pose; [threshold::T = 0.1]) where {T &lt;: AbstractFloat}</code></pre><p>Infers bonds for all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances of the given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a>. A new bond is assigned when a pair of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances are within a given distance, as defined in <code>ProtoSyn.Units.bond_lengths</code>. The <code>threshold</code> value is multiplied by the standard bond distance and added to the comparison value to allow some leeway in the bond distance (0.1, by default).</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.travel_bonds"><code>travel_bonds</code></a> <a href="#ProtoSyn.infer_parenthood!"><code>infer_parenthood!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.infer_bonds!(pose)
Pose{Topology}(Topology{/CRV:54976}, State{Float64}:
 Size: 201
 i2c: false | c2i: false
 Energy: Dict(:Total =&gt; Inf)
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L752-L773">source</a></section></article><h2 id="Travelling-the-Graph"><a class="docs-heading-anchor" href="#Travelling-the-Graph">Travelling the Graph</a><a id="Travelling-the-Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Travelling-the-Graph" title="Permalink"></a></h2><p>As further explored in the <a href="../../types/#graph-types">Graph</a> section, the directed nature of the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a>&#39;s <a href="../../types/#graph-types">Graph</a> allows for easy travelling of the system. The following methods facilitate that process.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.get_graph_size" href="#ProtoSyn.get_graph_size"><code>ProtoSyn.get_graph_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_graph_size(atom::Atom; depth::Int = 1, max_depth::Int = 10)</code></pre><p>Recursivelly search the the <a href="../../types/#graph-types">Graph</a> starting from <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> (inclusive) until no children are identified or the <code>depth</code> &gt; <code>max_depth</code> (10, by default).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.get_graph_size(pose.graph[1][73][&quot;CA&quot;])
13

julia&gt; ProtoSyn.get_graph_size(pose.graph[1][73][&quot;C&quot;])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/travel-graph.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.sort_children" href="#ProtoSyn.sort_children"><code>ProtoSyn.sort_children</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sort_children(atom::Atom; rev::Bool = false)</code></pre><p>Sort the given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> children, by the following criteria:</p><ol><li>By <a href="../../types/#graph-types">Graph</a> size (follow <a href="../../types/#graph-types">Graph</a> by employing the <a href="#ProtoSyn.get_graph_size"><code>get_graph_size</code></a>, small chains first)</li><li>By <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> name (in case all children chains have the same size; alphabetical order)</li></ol><p>By setting <code>rev</code> to <code>true</code> (<code>false</code>, by default), reverses the provided order.</p><pre><code class="nohighlight hljs">sort_children!(atom::Atom; rev::Bool = false)</code></pre><p>Sort the given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> children and save the newly sorted childen in <code>atom.bonds</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.sort_children!(pose.graph[1][72][&quot;CA&quot;])
3-element Vector{Atom}:
 Atom{/2a3d:31788/A:1/HIS:72/HA:1112}
 Atom{/2a3d:31788/A:1/HIS:72/CB:1113}
 Atom{/2a3d:31788/A:1/HIS:72/C:1124}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/travel-graph.jl#L29-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.travel_graph" href="#ProtoSyn.travel_graph"><code>ProtoSyn.travel_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">travel_graph(start::Atom; [stop::Opt{Atom} = nothing], [search_algorithm::F = ProtoSyn.BFS]) where {F &lt;: SearchAlgorithm})</code></pre><p>Return a <code>Vector{Atom}</code> with all atom instances between <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>start</code> and <code>stop</code> (inclusive), while following the structure&#39;s <a href="../../types/#state-types">Graph</a>. If no <code>stop</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance is provided or if it isn&#39;t found as a downstream parent of the <code>start</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, all instances until no children <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances are found are returned (for example, until the end of the current <a href="../../types/#pose-types">Pose</a> of <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a>). By default, uses Breath First Search (BFS) algorithm (all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances at the same &quot;graph-distance&quot; to the <code>start</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> are consumed before the next level is considered, order is given by <a href="#ProtoSyn.sort_children"><code>sort_children</code></a>). Optionally, by setting <code>search_algorithm</code> to <code>ProtoSyn.DFS</code>, can employ Depth First Algorithm (DFS) (the largest chain of <code>atom.children</code> is recursively exhausted before consuming the smaller chains, order is given by <a href="#ProtoSyn.sort_children"><code>sort_children</code></a>).</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.is_contiguous"><code>is_contiguous</code></a> <a href="#ProtoSyn.hasparent"><code>hasparent</code></a> <a href="#ProtoSyn.setparent!"><code>setparent!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.travel_graph(pose.graph[1][5][&quot;N&quot;], stop = pose.graph[1][6][&quot;N&quot;], search_algorithm = ProtoSyn.BFS)
11-element Vector{Atom}:
 Atom{/2a3d:31788/A:1/ALA:5/N:62}
 Atom{/2a3d:31788/A:1/ALA:5/H:63}
 Atom{/2a3d:31788/A:1/ALA:5/CA:64}
 Atom{/2a3d:31788/A:1/ALA:5/HA:65}
 Atom{/2a3d:31788/A:1/ALA:5/CB:66}
 Atom{/2a3d:31788/A:1/ALA:5/C:70}
 Atom{/2a3d:31788/A:1/ALA:5/HB3:69}
 Atom{/2a3d:31788/A:1/ALA:5/HB2:68}
 Atom{/2a3d:31788/A:1/ALA:5/HB1:67}
 Atom{/2a3d:31788/A:1/ALA:5/O:71}
 Atom{/2a3d:31788/A:1/GLU:6/N:72}

julia&gt; ProtoSyn.travel_graph(pose.graph[1][5][&quot;N&quot;], stop = pose.graph[1][6][&quot;N&quot;], search_algorithm = ProtoSyn.DFS)
4-element Vector{Atom}:
 Atom{/2a3d:31788/A:1/ALA:5/N:62}
 Atom{/2a3d:31788/A:1/ALA:5/CA:64}
 Atom{/2a3d:31788/A:1/ALA:5/C:70}
 Atom{/2a3d:31788/A:1/GLU:6/N:72}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/travel-graph.jl#L151-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.travel_bonds" href="#ProtoSyn.travel_bonds"><code>ProtoSyn.travel_bonds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">travel_graph(start::Atom; [stop::Opt{Atom} = nothing], [search_algorithm::F = ProtoSyn.BFS]) where {F &lt;: SearchAlgorithm})</code></pre><p>Return a <code>Vector{Atom}</code> with all atom instances between <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>start</code> and <code>stop</code> (inclusive), while following the structure&#39;s <a href="../../types/#state-types">Graph</a>. If no <code>stop</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance is provided or if it isn&#39;t found as a downstream parent of the <code>start</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, all instances until no children <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances are found are returned (for example, until the end of the current <a href="../../types/#pose-types">Pose</a> of <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a>). By default, uses Breath First Search (BFS) algorithm (all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances at the same &quot;graph-distance&quot; to the <code>start</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> are consumed before the next level is considered, order is given by <a href="#ProtoSyn.sort_children"><code>sort_children</code></a>). Optionally, by setting <code>search_algorithm</code> to <code>ProtoSyn.DFS</code>, can employ Depth First Algorithm (DFS) (the largest chain of <code>atom.children</code> is recursively exhausted before consuming the smaller chains, order is given by <a href="#ProtoSyn.sort_children"><code>sort_children</code></a>).</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.is_contiguous"><code>is_contiguous</code></a> <a href="#ProtoSyn.hasparent"><code>hasparent</code></a> <a href="#ProtoSyn.setparent!"><code>setparent!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.travel_graph(pose.graph[1][5][&quot;N&quot;], stop = pose.graph[1][6][&quot;N&quot;], search_algorithm = ProtoSyn.BFS)
11-element Vector{Atom}:
 Atom{/2a3d:31788/A:1/ALA:5/N:62}
 Atom{/2a3d:31788/A:1/ALA:5/H:63}
 Atom{/2a3d:31788/A:1/ALA:5/CA:64}
 Atom{/2a3d:31788/A:1/ALA:5/HA:65}
 Atom{/2a3d:31788/A:1/ALA:5/CB:66}
 Atom{/2a3d:31788/A:1/ALA:5/C:70}
 Atom{/2a3d:31788/A:1/ALA:5/HB3:69}
 Atom{/2a3d:31788/A:1/ALA:5/HB2:68}
 Atom{/2a3d:31788/A:1/ALA:5/HB1:67}
 Atom{/2a3d:31788/A:1/ALA:5/O:71}
 Atom{/2a3d:31788/A:1/GLU:6/N:72}

julia&gt; ProtoSyn.travel_graph(pose.graph[1][5][&quot;N&quot;], stop = pose.graph[1][6][&quot;N&quot;], search_algorithm = ProtoSyn.DFS)
4-element Vector{Atom}:
 Atom{/2a3d:31788/A:1/ALA:5/N:62}
 Atom{/2a3d:31788/A:1/ALA:5/CA:64}
 Atom{/2a3d:31788/A:1/ALA:5/C:70}
 Atom{/2a3d:31788/A:1/GLU:6/N:72}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/travel-graph.jl#L219-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.identify_atom_by_bonding_pattern" href="#ProtoSyn.identify_atom_by_bonding_pattern"><code>ProtoSyn.identify_atom_by_bonding_pattern</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">identify_atom_by_bonding_pattern(container::AbstractContainer, pattern::Vector{String})</code></pre><p>Returns one or more candidate <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances from the given <code>AbstractContainer</code> <code>container</code> that match the provided <code>pattern</code> (a Vector of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> elements). This method follows the following hierarchical criteria:</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.identify_atom_by_bonding_pattern(pose.graph[1][1], [&quot;H&quot;, &quot;N&quot;, &quot;C&quot;, &quot;C&quot;])
3-element Vector{Atom}:
 Atom{/2a3d:3900/A:1/MET:1/H1:2}
 Atom{/2a3d:3900/A:1/MET:1/H2:3}
 Atom{/2a3d:3900/A:1/MET:1/H3:4}

julia&gt; ProtoSyn.identify_atom_by_bonding_pattern(pose.graph[1][1], [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;H&quot;])
Atom{/2a3d:3900/A:1/MET:1/C:18}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/graph.jl#L801-L820">source</a></section></article><p>As explained above, certain methods in ProtoSyn travel the directed graph. There are, however, multiple ways to follow the same graph (as longs as its ramified), depending on the criteria used on bifurcations. In the Core module, ProtoSyn makes available for the BFS (breath-first search) and DFs (depth-first search) algorithms, a type of <code>SearchAlgorithm</code>.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.BFS" href="#ProtoSyn.BFS"><code>ProtoSyn.BFS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">(ProtoSyn.BFS)(atom::Atom, stack::Vector{Atom})</code></pre><p>Breath first search algorithm for <a href="#ProtoSyn.travel_graph"><code>travel_graph</code></a>. Correctly sorts the given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> children instances and concatenates with the current <code>stack</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.BFS(pose.graph[1][1][&quot;CA&quot;], Vector{Atom}())
3-element Vector{Atom}:
 Atom{/test:36441/A:1/MET:1/HA:6}
 Atom{/test:36441/A:1/MET:1/C:7}
 Atom{/test:36441/A:1/MET:1/CB:8}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/travel-graph.jl#L106-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.DFS" href="#ProtoSyn.DFS"><code>ProtoSyn.DFS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">(ProtoSyn.DFS)(atom::Atom, stack::Vector{Atom})</code></pre><p>Depth first search algorithm for <a href="#ProtoSyn.travel_graph"><code>travel_graph</code></a>. Correctly sorts the given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> children instances and concatenates with the current <code>stack</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.DFS(pose.graph[1][1][&quot;CA&quot;], Vector{Atom}())
3-element Vector{Atom}:
 Atom{/test:36441/A:1/MET:1/CB:8}
 Atom{/test:36441/A:1/MET:1/C:7}
 Atom{/test:36441/A:1/MET:1/HA:6}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Methods/travel-graph.jl#L132-L147">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../types/">« Types</a><a class="docs-footer-nextpage" href="../state/">State »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Tuesday 16 August 2022 14:09">Tuesday 16 August 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
