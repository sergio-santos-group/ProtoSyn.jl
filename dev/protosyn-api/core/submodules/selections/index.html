<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Selections · ProtoSyn.jl</title><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="ProtoSyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">ProtoSyn.jl</a></span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../../../getting-started/installation/">Installation</a></li><li><a class="tocitem" href="../../../../getting-started/first-steps/">First steps</a></li><li><a class="tocitem" href="../../../../getting-started/examples/">Examples</a></li></ul></li><li><span class="tocitem">ProtoSyn API</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-1-2" type="checkbox"/><label class="tocitem" for="menuitem-3-1-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../methods/graph/">Graph</a></li><li><a class="tocitem" href="../../methods/state/">State</a></li><li><a class="tocitem" href="../../methods/pose/">Pose</a></li><li><a class="tocitem" href="../../methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../methods/other/">Auxiliary methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-3" type="checkbox"/><label class="tocitem" for="menuitem-3-1-3"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../calculators/calculators-section/">Calculators Section</a></li><li><a class="tocitem" href="../../calculators/torchani/">TorchANI</a></li><li><a class="tocitem" href="../../calculators/bond-distance-restraint/">Bond distance Restraint</a></li><li><a class="tocitem" href="../../calculators/potential-restraints/">Potential Restraints</a></li><li><a class="tocitem" href="../../calculators/electrostatics/">Electrostatics</a></li><li><a class="tocitem" href="../../calculators/gb-solvation/">Generalized Born</a></li><li><a class="tocitem" href="../../calculators/sasa/">SASA</a></li><li><a class="tocitem" href="../../calculators/hydrogen-bonds/">Hydrogen Bonds</a></li><li><a class="tocitem" href="../../calculators/radius-gyration/">Radius of gyration</a></li><li><a class="tocitem" href="../../calculators/custom-ref-energy/">Custom reference energy</a></li><li><a class="tocitem" href="../../calculators/ref15/">REF-15</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-4" type="checkbox"/><label class="tocitem" for="menuitem-3-1-4"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mutators/mutators-section/">Mutators Section</a></li><li><a class="tocitem" href="../../mutators/mutators-dihedral/">Dihedral Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-crankshaft/">Crankshaft Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-rigid-body/">Rigid Body Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-backrub/">Backrub Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-compound/">Compound Mutators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-5" type="checkbox"/><label class="tocitem" for="menuitem-3-1-5"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../drivers/drivers-section/">Drivers Section</a></li><li><a class="tocitem" href="../../drivers/drivers-monte-carlo/">Monte Carlo</a></li><li><a class="tocitem" href="../../drivers/drivers-steepest-descent/">Steepest Descent</a></li><li><a class="tocitem" href="../../drivers/drivers-ils/">ILS</a></li><li><a class="tocitem" href="../../drivers/drivers-compound/">Compound Driver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-6" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Selections</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Available-selections"><span>Available selections</span></a></li><li class="toplevel"><a class="tocitem" href="#Masks"><span>Masks</span></a></li><li class="toplevel"><a class="tocitem" href="#Promotion"><span>Promotion</span></a></li><li class="toplevel"><a class="tocitem" href="#Combining-selections"><span>Combining selections</span></a></li><li class="toplevel"><a class="tocitem" href="#Applying-selections"><span>Applying selections</span></a></li></ul></li><li><a class="tocitem" href="../builder/">Builder</a></li><li><a class="tocitem" href="../external-packages/">External packages</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Peptides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../peptides/types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-2-3" type="checkbox"/><label class="tocitem" for="menuitem-3-2-3"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../../peptides/methods/graph/">Graph</a></li><li><a class="tocitem" href="../../../peptides/methods/state/">State</a></li><li><a class="tocitem" href="../../../peptides/methods/pose/">Pose</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-4" type="checkbox"/><label class="tocitem" for="menuitem-3-2-4"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/calculators/potential-restraints/">Potential Restraints</a></li><li><a class="tocitem" href="../../../peptides/calculators/electrostatics/">Electrostatics</a></li><li><a class="tocitem" href="../../../peptides/calculators/sasa/">SASA</a></li><li><a class="tocitem" href="../../../peptides/calculators/natural-frequency/">Natural frequency</a></li><li><a class="tocitem" href="../../../peptides/calculators/ss-propensity/">Secondary structure propensity</a></li><li><a class="tocitem" href="../../../peptides/calculators/caterpillar-solvation/">Caterpilar solvation model</a></li><li><a class="tocitem" href="../../../peptides/calculators/seqdes/">SeqDes model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-5" type="checkbox"/><label class="tocitem" for="menuitem-3-2-5"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/mutators/rotamer/">Rotamer Mutator</a></li><li><a class="tocitem" href="../../../peptides/mutators/design/">Design Mutator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-6" type="checkbox"/><label class="tocitem" for="menuitem-3-2-6"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/drivers/rotamer-blitz-driver/">Rotamer Blitz</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-7" type="checkbox"/><label class="tocitem" for="menuitem-3-2-7"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../../peptides/submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../../peptides/submodules/rotamers/">Rotamers</a></li><li><a class="tocitem" href="../../../peptides/submodules/external-packages/">External packages</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Materials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-3-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/methods/lattices/">Lattices</a></li><li><a class="tocitem" href="../../../materials/methods/carbons/">Carbons</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Sugars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/submodules/builder/">Builder</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../common/introduction/">Introduction</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ProtoSyn API</a></li><li><a class="is-disabled">Core</a></li><li><a class="is-disabled">Submodules</a></li><li class="is-active"><a href>Selections</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Selections</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/master/docs/src/protosyn-api/core/submodules/selections.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="core-selections"><a class="docs-heading-anchor" href="#core-selections">Selections</a><a id="core-selections-1"></a><a class="docs-heading-anchor-permalink" href="#core-selections" title="Permalink"></a></h1><blockquote><p>The <a href="#core-selections">Selections</a> are a submodule of <code>ProtoSyn.Core</code> module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.</p></blockquote><p>ProtoSyn comes equipped with a powerful syntax for selecting parts of molecular systems based on several different parameters. The parent type of all <a href="#core-selections">Selections</a> is an <code>AbstractSelection</code>, which is parametrized by 2 different static types:</p><ul><li><p>First, a <strong>State mode</strong> (of abstract type <code>AbstractStateMode</code>) indicates whether an <code>AbstractSelection</code> is <code>Stateful</code> or <code>Stateless</code>.</p><ul><li><code>Stateful</code> selections require a <a href="../../types/#ProtoSyn.State"><code>State</code></a> in order to correctly calculate the Selection. An example would be a Selection that selects all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances within 10Å of a given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>.</li><li><code>Stateless</code> selections do not require a <a href="../../types/#ProtoSyn.State"><code>State</code></a>. An example would be a Selection that selects all residues named &quot;ALA&quot;.</li></ul></li><li><p>Secondly, a <strong>Selection type</strong> is an instance of <code>AbstractContainer</code> (such as an <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> or <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a>), and indicates the type of molecular structure that in being queried. For example, depending on the selection type, we can select all <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances named &quot;ALA&quot; or all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances named &quot;ALA&quot;.</p></li></ul><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>Some <code>AbstractSelection</code> types can use regular expressions (Regex) to search for the desired parameter. Such cases are discussed individually.</p></div></div><p><a href="#core-selections">Selections</a>, when applied to an <code>AbstractContainer</code>, return a binary <a href="#ProtoSyn.Mask"><code>Mask</code></a> (see <a href="#Masks">Masks</a> section). These can be combined with others <a href="#Masks">Masks</a> (see <a href="#Combining-selections">Combining selections</a>), used directly in <a href="../../methods/pose/#pose-methods">Methods</a> or gathered to a list of the actual instances of <code>AbstractContainer</code> (see <a href="#Applying-selections">Applying selections</a> section).</p><p>The <a href="#core-selections">Selections</a> section will be sub-divided in the following topics, for organization:</p><ul><li><a href="#Available-selections">Available selections</a></li><li><a href="#Masks">Masks</a></li><li><a href="#Promotion">Promotion</a></li><li><a href="#Combining-selections">Combining selections</a></li><li><a href="#Applying-selections">Applying selections</a></li></ul><h1 id="Available-selections"><a class="docs-heading-anchor" href="#Available-selections">Available selections</a><a id="Available-selections-1"></a><a class="docs-heading-anchor-permalink" href="#Available-selections" title="Permalink"></a></h1><p>In this section the list all available <code>AbstractSelection</code> types will be explored.</p><ul><li><a href="#ProtoSyn.SerialSelection"><code>SerialSelection</code></a></li><li><a href="#ProtoSyn.RangeSelection"><code>RangeSelection</code></a></li><li><a href="#ProtoSyn.FieldSelection"><code>FieldSelection</code></a></li><li><a href="#ProtoSyn.UpstreamTerminalSelection"><code>UpstreamTerminalSelection</code></a></li><li><a href="#ProtoSyn.DownstreamTerminalSelection"><code>DownstreamTerminalSelection</code></a></li><li><a href="#ProtoSyn.DistanceSelection"><code>DistanceSelection</code></a></li><li><a href="#ProtoSyn.RandomSelection"><code>RandomSelection</code></a></li><li><a href="#ProtoSyn.RandomSelectionFromList"><code>RandomSelectionFromList</code></a></li><li><a href="#ProtoSyn.RandomRangeSelection"><code>RandomRangeSelection</code></a></li><li><a href="#ProtoSyn.TrueSelection"><code>TrueSelection</code></a></li><li><a href="#ProtoSyn.UnarySelection"><code>UnarySelection</code></a></li><li><a href="#ProtoSyn.AromaticSelection"><code>AromaticSelection</code></a></li><li><a href="#ProtoSyn.BondCountSelection"><code>BondCountSelection</code></a></li><li><a href="#ProtoSyn.BondedToSelection"><code>BondedToSelection</code></a></li><li><a href="#ProtoSyn.ChargeSelection"><code>ChargeSelection</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.SerialSelection" href="#ProtoSyn.SerialSelection"><code>ProtoSyn.SerialSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SerialSelection{T}(serial::Int, field::Symbol) where {T &lt;: AbstractContainer}</code></pre><p>A <a href="#ProtoSyn.SerialSelection"><code>SerialSelection</code></a> selects instances based on <code>:id</code> and <code>:index</code>. It takes an input <code>serial</code> (as an <code>Int</code>) and a <code>field</code> (as a <code>Symbol</code>) and outputs a <a href="#ProtoSyn.Mask"><code>Mask</code></a> (of type <code>T &lt;: AbstractContainer</code>) containing all instances of said type in the given <code>container</code> whose <code>field</code> matches the <code>serial</code> number given marked as <code>true</code>. This selection works similarly to <a href="#ProtoSyn.FieldSelection"><code>FieldSelection</code></a>, but is especialized in dealing with number variables.</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.SerialSelection"><code>SerialSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.SerialSelection"><code>SerialSelection</code></a> can be any <code>T &lt;: AbstractContainer</code>.</p><p><strong>Short syntax</strong></p><ul><li>sid&quot;...&quot; = Segment ID;</li><li>rid&quot;...&quot; = Residue ID;</li><li>aid&quot;...&quot; = Atom ID;</li><li>six&quot;...&quot; = Segment Index;</li><li>rix&quot;...&quot; = Residue Index;</li><li>aix&quot;...&quot; = Atom Index;</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = SerialSelection{Segment}(1, :id)
SerialSelection › Segment.id = 1

julia&gt; sele = SerialSelection{Atom}(2, :index)
SerialSelection › Atom.index = 2

julia&gt; sele = sid&quot;1&quot;
SerialSelection › Segment.id = 1

julia&gt; sele = aix&quot;2&quot;
SerialSelection › Atom.index = 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/serial.jl#L4-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.RangeSelection" href="#ProtoSyn.RangeSelection"><code>ProtoSyn.RangeSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RangeSelection{T}(range::UnitRange{Int}, field::Symbol) where {T &lt;: AbstractContainer}</code></pre><p>A <a href="#ProtoSyn.RangeSelection"><code>RangeSelection</code></a> takes an input <code>range</code> (as an <code>UnitRange{Int}</code>) and a <code>field</code> (as a <code>Symbol</code>) and outputs a <a href="#ProtoSyn.Mask"><code>Mask</code></a> (of type <code>T &lt;: AbstractContainer</code>) containing all instances of said type in the given <code>container</code> whose <code>field</code> matches is in the <code>range</code> given. This selection works simillarly to <a href="#ProtoSyn.FieldSelection"><code>FieldSelection</code></a>, but is especialized in dealing with numbers.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>The <a href="#ProtoSyn.RangeSelection"><code>RangeSelection</code></a> is inclusive, meaning the <code>:id</code> of <code>:index</code> given in the selection will also be included in the selected <a href="#ProtoSyn.Mask"><code>Mask</code></a>.</p></div></div><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.RangeSelection"><code>RangeSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.RangeSelection"><code>RangeSelection</code></a> can be any <code>T &lt;: AbstractContainer</code>.</p><p><strong>Short syntax</strong></p><ul><li>sid&quot;...&quot; = Segment ID</li><li>rid&quot;...&quot; = Residue ID</li><li>aid&quot;...&quot; = Atom ID</li><li>six&quot;...&quot; = Segment Index;</li><li>rix&quot;...&quot; = Residue Index;</li><li>aix&quot;...&quot; = Atom Index;</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = RangeSelection{Segment}(1:4, :id)
RangeSelection › Segment.id between 1 and 4

julia&gt; sele = RangeSelection{Atom}(2:10, :index)
RangeSelection › Atom.index between 2 and 10

julia&gt; sele = sid&quot;1:4&quot;
RangeSelection › Segment.id between 1 and 4

julia&gt; sele = aix&quot;2:10&quot;
RangeSelection › Atom.index between 2 and 10</code></pre><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection assumes that all <code>Abstractcontainer</code> instances are ordered (i.e: <code>aid&quot;1:10&quot;</code> will select atoms 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/serial.jl#L99-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.FieldSelection" href="#ProtoSyn.FieldSelection"><code>ProtoSyn.FieldSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldSelection{T}(pattern::String, field::Symbol, [is_regex::Bool = false]) where {T &lt;: AbstractContainer}</code></pre><p>A <a href="#ProtoSyn.FieldSelection"><code>FieldSelection</code></a> takes an input <code>pattern</code> (as a <code>String</code>) and a <code>field</code> (as a <code>Symbol</code>) and outputs a <code>Mask</code> (of type <code>T &lt;: AbstractContainer</code>) containing all instances of said type in the given <code>container</code> whose <code>field</code> matches the <code>pattern</code> marked as <code>true</code>. The given <code>pattern</code> can be considered as a Regular Expression (<code>Regex</code>), if <code>is_regex</code> flag is set to <code>true</code>. Optinally, when using a short syntax, appending an &quot;r&quot; flag at the end of the expression also sets <code>is_regex</code> to <code>true</code>.</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.FieldSelection"><code>FieldSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.FieldSelection"><code>FieldSelection</code></a> can be any <code>T &lt;: AbstractContainer</code>.</p><p><strong>Short syntax</strong></p><ul><li>an&quot;...&quot; = Atom name</li><li>as&quot;...&quot; = Atom symbol</li><li>rn&quot;...&quot; = Residue name</li><li>sn&quot;...&quot; = Segment name</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = FieldSelection{Atom}(&quot;C&quot;, :symbol)
FieldSelection › Atom.symbol = C

julia&gt; sele = FieldSelection{Residue}(&quot;AL*&quot;, :name, is_regex = true)
FieldSelection › Residue.name = r&quot;AL*&quot;

julia&gt; sele = as&quot;C&quot;
FieldSelection › Atom.symbol = C

julia&gt; sele = rn&quot;AL*&quot;r
FieldSelection › Residue.name = r&quot;AL*&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/field.jl#L4-L43">source</a></section></article><p><img src="../../../../assets/ProtoSyn-select-1.png" alt="ProtoSyn selections1"/></p><p><strong>Figure 1 |</strong> An example of a Serial, Range and Field selections being employed.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.UpstreamTerminalSelection" href="#ProtoSyn.UpstreamTerminalSelection"><code>ProtoSyn.UpstreamTerminalSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UpstreamTerminalSelection{T}() where {T &lt;: AbstractContainer}</code></pre><p>An <a href="#ProtoSyn.UpstreamTerminalSelection"><code>UpstreamTerminalSelection</code></a> returns a <a href="#ProtoSyn.Mask"><code>Mask</code></a> selecting only the upstream terminal <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> or <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> or <code>AbstractContainer</code>. Upstream terminal instances are defined as being children of the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> or <code>AbstractContainer</code> <a href="../../methods/graph/#ProtoSyn.root"><code>root</code></a>.</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.UpstreamTerminalSelection"><code>UpstreamTerminalSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.UpstreamTerminalSelection"><code>UpstreamTerminalSelection</code></a> <code>T</code> is forced to be either <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> or <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = UpstreamTerminalSelection{Residue}()
UpstreamTerminalSelection (Residue)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/terminal.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.DownstreamTerminalSelection" href="#ProtoSyn.DownstreamTerminalSelection"><code>ProtoSyn.DownstreamTerminalSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DownstreamTerminalSelection{T}() where {T &lt;: AbstractContainer}</code></pre><p>A <a href="#ProtoSyn.DownstreamTerminalSelection"><code>DownstreamTerminalSelection</code></a> returns a <a href="#ProtoSyn.Mask"><code>Mask</code></a> selecting only downstream terminal <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> or <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> or <code>AbstractContainer</code>. Downstream terminal instances are defined as instances with a parent but no children.</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.DownstreamTerminalSelection"><code>DownstreamTerminalSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.DownstreamTerminalSelection"><code>DownstreamTerminalSelection</code></a> <code>T</code> is forced to be either <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> or <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = DownstreamTerminalSelection()
DownstreamTerminalSelection (Residue)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/terminal.jl#L76-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.DistanceSelection" href="#ProtoSyn.DistanceSelection"><code>ProtoSyn.DistanceSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DistanceSelection(distance::Number, sele::S) where {S &lt;: AbstractSelection}</code></pre><p>A <a href="#ProtoSyn.DistanceSelection"><code>DistanceSelection</code></a> takes an input selection <code>sele</code> and outputs a <a href="#ProtoSyn.Mask"><code>Mask</code></a> of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances within the given <code>distance</code> (in Ansgtrom Å) of the selected atoms from <code>sele</code>.</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.DistanceSelection"><code>DistanceSelection</code></a> <code>M</code> is forced to be Stateful</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.DistanceSelection"><code>DistanceSelection</code></a> <code>T</code> is forced to be <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = DistanceSelection(2.0, rn&quot;ALA&quot;)
DistanceSelection ❯ Within 2.0 Å (Atom)
 └── FieldSelection › Residue.name = ALA

julia&gt; 2.0:rn&quot;ALA&quot;
DistanceSelection ❯ Within 2.0 Å (Atom)
 └── FieldSelection › Residue.name = ALA</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/distance.jl#L4-L28">source</a></section></article><p><img src="../../../../assets/ProtoSyn-select-2.png" alt="ProtoSyn selections2"/></p><p><strong>Figure 2 |</strong> An example of the Terminal and Distance selections being employed.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.RandomSelection" href="#ProtoSyn.RandomSelection"><code>ProtoSyn.RandomSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomSelection{T}(sele::Opt{AbstractSelection}) where {T &lt;: AbstractContainer}</code></pre><p>A <a href="#ProtoSyn.RandomSelection"><code>RandomSelection</code></a> outputs a <a href="#ProtoSyn.Mask"><code>Mask</code></a> (of type <code>T &lt;: AbstractContainer</code>) containing a random instance of said type in the given <code>container</code>. Optionally, if an <code>AbstractSelection</code> <code>sele</code> is provided, the random selection is performed from the previously selected instances (from the inner <code>sele</code>). Note that, despite the inner <code>sele</code> selection type, the output will always be promoted to be of <code>T</code> type (using the <a href="../../../internals/#ProtoSyn.promote"><code>promote</code></a> method.)</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.RandomSelection"><code>RandomSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.RandomSelection"><code>RandomSelection</code></a> can be any <code>T &lt;: AbstractContainer</code>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = RandomSelection{Residue}()
RandomSelection › Residue.id

julia&gt; RandomSelection{Atom}(rid&quot;1&quot;)
RandomSelection › Atom.id › From
 └── SerialSelection › Residue.id = 1

julia&gt; RandomSelection{Atom}(an&quot;C&quot; &amp; rid&quot;1&quot;)
RandomSelection › Atom.id › From
 └── BinarySelection ❯  &amp; &quot;and&quot; (Atom)
      ├── FieldSelection › Atom.name = C
      └── SerialSelection › Residue.id = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/random.jl#L4-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.RandomSelectionFromList" href="#ProtoSyn.RandomSelectionFromList"><code>ProtoSyn.RandomSelectionFromList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomSelectionFromList(selections::Vector{T}) where {T &lt;: AbstractSelection}</code></pre><p>A <a href="#ProtoSyn.RandomSelectionFromList"><code>RandomSelectionFromList</code></a> outputs a <a href="#ProtoSyn.Mask"><code>Mask</code></a> (of type <code>T &lt;: AbstractContainer</code>). This <a href="#ProtoSyn.Mask"><code>Mask</code></a> is the result of the application of a randomly selected <code>AbstractSelection</code> from the provided list of <code>AbstractSelection</code> instances <code>selections</code>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>All the given <code>AbstractSelection</code> instances must be of the same type.</p></div></div><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.RandomSelectionFromList"><code>RandomSelectionFromList</code></a> <code>M</code> is the same as the state mode of the provided list of <code>AbstractSelection</code> instances (which are all of the same type).</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.RandomSelectionFromList"><code>RandomSelectionFromList</code></a> <code>M</code> is the same as the selection type of the provided list of <code>AbstractSelection</code> instances (which are all of the same type).</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = ProtoSyn.RandomSelectionFromList([rid&quot;1&quot;, rid&quot;2&quot;])
RandomSelectionFromList ❯ (Residue)
 ├── SerialSelection › Residue.id = 1
 └── SerialSelection › Residue.id = 2
 
julia&gt; s = ProtoSyn.RandomSelectionFromList([rid&quot;1&quot;, rn&quot;CBZ&quot;])
ERROR: AssertionError: RandomSelectionFromList `selections` elements must be all of the same type.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/random.jl#L171-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.RandomRangeSelection" href="#ProtoSyn.RandomRangeSelection"><code>ProtoSyn.RandomRangeSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomRangeSelection{T}() where {T &lt;: AbstractContainer}</code></pre><p>A <a href="#ProtoSyn.RandomRangeSelection"><code>RandomRangeSelection</code></a> outputs a <a href="#ProtoSyn.Mask"><code>Mask</code></a> (of type <code>T &lt;: AbstractContainer</code>) containing a random range of instances of said type in the given <code>container</code>. The considered range is based on the instance&#39;s <code>:id</code>.</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.RandomRangeSelection"><code>RandomRangeSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.RandomRangeSelection"><code>RandomRangeSelection</code></a> can be any <code>T &lt;: AbstractContainer</code>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = RandomRangeSelection{Residue}()
RandomRangeSelection › Residue.id</code></pre><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection assumes that all <code>Abstractcontainer</code> instances are ordered (i.e: a random range between atom 1 and atom 10 will select atoms 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/random.jl#L105-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.AromaticSelection" href="#ProtoSyn.AromaticSelection"><code>ProtoSyn.AromaticSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AromaticSelection([d::Int = 6])</code></pre><p>An <a href="#ProtoSyn.AromaticSelection"><code>AromaticSelection</code></a> selects <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances that belong to an aromatic ring. Rings are identified by their bonds, using the <a href="../../methods/graph/#ProtoSyn.travel_bonds"><code>travel_bonds</code></a> method: any atom who exists in the set of bonded atoms within <code>d</code> bonds to itself forms a ring (d = 6, by default). </p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.SerialSelection"><code>SerialSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.SerialSelection"><code>SerialSelection</code></a> <code>T</code> is forced to be <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AromaticSelection(6)
AromaticSelection (Rings with 6 or less bonds) › (Atom)

julia&gt; AromaticSelection(7)
AromaticSelection (Rings with 7 or less bonds) › (Atom)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/aromatic.jl#L4-L33">source</a></section></article><p><img src="../../../../assets/ProtoSyn-select-3.png" alt="ProtoSyn selections3"/></p><p><strong>Figure 3 |</strong> An example of the Aromatic selection being employed.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.BondCountSelection" href="#ProtoSyn.BondCountSelection"><code>ProtoSyn.BondCountSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BondCountSelection{T}(n::Int, op::Function = ===)</code></pre><p>A <a href="#ProtoSyn.BondCountSelection"><code>BondCountSelection</code></a> takes an input <code>n</code> value and an <code>op</code> (as a <code>Function</code>, is <code>===</code>, by default) and outputs a <code>Mask</code> (of type <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>) containing all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances whose number of bonded <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances (in <code>atom.bonds</code>) matches the given <code>n</code> (when compared with <code>op</code>). As an example, <code>op</code> can be <code>&gt;</code>, <code>&lt;=</code>, <code>==</code>, etc.</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.BondCountSelection"><code>BondCountSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.BondCountSelection"><code>BondCountSelection</code></a> is forced to be <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BondCountSelection(1)
BondCountSelection (Atoms with N bonds === 1) › (Atom)

julia&gt; BondCountSelection(3, &gt;)
BondCountSelection (Atoms with N bonds &gt; 3) › (Atom)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/bond-count.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.BondedToSelection" href="#ProtoSyn.BondedToSelection"><code>ProtoSyn.BondedToSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BondedToSelection(sele::S)</code></pre><p>A <a href="#ProtoSyn.BondedToSelection"><code>BondedToSelection</code></a> takes an input selection <code>sele</code> and outputs a <a href="#ProtoSyn.Mask"><code>Mask</code></a> of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances which are bonded to any selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> from the inner <code>sele</code>. Note that the inner <code>sele</code> is automatically promoted to be of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> selection type (using the <a href="../../../internals/#ProtoSyn.promote"><code>promote</code></a> method).</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.BondedToSelection"><code>BondedToSelection</code></a> <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.BondedToSelection"><code>BondedToSelection</code></a> <code>T</code> is forced to be <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BondedToSelection(an&quot;C&quot;)
BondedToSelection ❯ (Atom)
 └── FieldSelection › Atom.name = C</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/bond.jl#L4-L29">source</a></section></article><p><img src="../../../../assets/ProtoSyn-select-4.png" alt="ProtoSyn selections4"/></p><p><strong>Figure 4 |</strong> An example of the Bond Count and Bonded To selection being employed.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.ChargeSelection" href="#ProtoSyn.ChargeSelection"><code>ProtoSyn.ChargeSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ChargeSelection(charge::F, op::Function = ===) where {F &lt;: AbstractFloat}</code></pre><p>A <a href="#ProtoSyn.ChargeSelection"><code>ChargeSelection</code></a> takes an input <code>charge</code> value and an <code>op</code> (as a <code>Function</code>, is <code>===</code>, by default) and outputs a <code>Mask</code> (of type <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>) containing all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances whose <code>AtomState</code> charge matches the given <code>charge</code> (when compared with <code>op</code>). As an example, <code>op</code> can be <code>&gt;</code>, <code>&lt;=</code>, <code>==</code>, etc.</p><p><strong>State mode</strong></p><p>The state mode of <a href="#ProtoSyn.ChargeSelection"><code>ChargeSelection</code></a> <code>M</code> is forced to be <code>Stateful</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.ChargeSelection"><code>ChargeSelection</code></a> is forced to be <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ChargeSelection(1.0)
ChargeSelection (Atoms with charge === 1.0) › (Atom)

julia&gt; ChargeSelection(-1.0, &gt;)
ChargeSelection (Atoms with charge &gt; -1.0) › (Atom)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/charge.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.TrueSelection" href="#ProtoSyn.TrueSelection"><code>ProtoSyn.TrueSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrueSelection{T}()</code></pre><p>A <a href="#ProtoSyn.TrueSelection"><code>TrueSelection</code></a> returns a <a href="#ProtoSyn.Mask"><code>Mask</code></a> (of type <code>T &lt;: AbstractContainer</code>) with all entries set to <code>true</code>.</p><p><strong>State mode</strong></p><p>The state mode of [<code>TrueSelection</code>] <code>M</code> is forced to be <code>Stateless</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.RandomRangeSelection"><code>RandomRangeSelection</code></a> can be any <code>T &lt;: AbstractContainer</code>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = TrueSelection{Atom}()
TrueSelection (Atom)

julia&gt; sele = !TrueSelection{Atom}()
UnarySelection ❯ ! &quot;not&quot; (Atom)
 └── TrueSelection (Atom)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/true.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.UnarySelection" href="#ProtoSyn.UnarySelection"><code>ProtoSyn.UnarySelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnarySelection{M}(op::Function, sele::AbstractSelection)</code></pre><p>A <a href="#ProtoSyn.UnarySelection"><code>UnarySelection</code></a> applies an operation <code>op</code> to the given <code>AbstractSelection</code> <code>sele</code>. Available operations with short syntax:</p><ul><li><code>!</code> - Logical Not. Negates the values selected by <code>sele</code>.</li></ul><p><strong>State mode</strong></p><p>The selection type of <a href="#ProtoSyn.UnarySelection"><code>UnarySelection</code></a> can be either <code>Stateless</code> or <code>Stateful</code>. When using the short syntax, it will automatically be set to the <code>StateMode</code> of the provided <code>sele</code>.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.UnarySelection"><code>UnarySelection</code></a> can be any <code>T &lt;: AbstractContainer</code>. When queried for using the <code>selection_type</code> function, will return the selection type of the given <code>sele</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = !rn&quot;ALA&quot;
UnarySelection ❯ ! &quot;not&quot; (Residue)
 └── FieldSelection › Residue.name = ALA</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/unary.jl#L4-L29">source</a></section></article><h1 id="Masks"><a class="docs-heading-anchor" href="#Masks">Masks</a><a id="Masks-1"></a><a class="docs-heading-anchor-permalink" href="#Masks" title="Permalink"></a></h1><p><a href="#Masks">Masks</a> are the primary result of applying a Selection to an <code>AbstractContainer</code>. These are, in essence, arrays of <code>Bool</code> instances, set to <code>true</code> only on the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> or <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> instances that satisfy the restrictions imposed by any given selection (or combination of selections). The total size of a <a href="#ProtoSyn.Mask"><code>Mask</code></a> is the amount of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> or <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> instances in the <code>AbstractContainer</code> the selection is applied to (see <a href="#Applying-selections">Applying selections</a> section).</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Mask" href="#ProtoSyn.Mask"><code>ProtoSyn.Mask</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProtoSyn.Mask{T}(content::BitVector) where {T &lt;: AbstractContainer}</code></pre><p>A <code>Mask</code> is a typed wrapped on a <code>BitArray</code>, and therefore can be N dimensional. Utility functions are provided for <a href="#ProtoSyn.Mask"><code>Mask</code></a> instances up to 2D.</p><pre><code class="nohighlight hljs">ProtoSyn.Mask{T}() where {T &lt;: AbstractContainer}</code></pre><p>Return an empty <a href="#ProtoSyn.Mask"><code>Mask</code></a> of length 0.</p><pre><code class="nohighlight hljs">ProtoSyn.Mask{T}(n::Int) where {T &lt;: AbstractContainer}</code></pre><p>Return a <a href="#ProtoSyn.Mask"><code>Mask</code></a> of length <code>n</code> with all bits set to <code>false</code>.</p><pre><code class="nohighlight hljs">ProtoSyn.Mask{T}(n::Tuple{Int, Int}) where {T &lt;: AbstractContainer}
ProtoSyn.Mask{T}(n1::Int, n2::Int) where {T &lt;: AbstractContainer}</code></pre><p>Return a 2D <a href="#ProtoSyn.Mask"><code>Mask</code></a> of size <code>n</code> (or size <code>(n1, n2)</code>) with all bits set to <code>false</code>.</p><p><strong>Selection type</strong></p><p>The selection type of a <a href="#ProtoSyn.Mask"><code>Mask</code></a> instance can be any <code>T &lt;: AbstractContainer</code>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>Combinatory operators (<code>&amp;</code> and <code>|</code>) and unary operators (<code>!</code>) can be employed with <a href="#ProtoSyn.Mask"><code>Mask</code></a> instances.</p></div></div><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Mask{Atom}()
ProtoSyn.Mask{Atom}(0,)
0-element BitArray{1}

julia&gt; ProtoSyn.Mask{Residue}((3, 3))
ProtoSyn.Mask{Residue}(3, 3)
3×3 BitMatrix:
 0  0  0
 0  0  0
 0  0  0

julia&gt; !ProtoSyn.Mask{Atom}(5)
ProtoSyn.Mask{Atom}(5,)
5-element BitVector:
 1
 1
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/masks.jl#L3-L54">source</a></section></article><h1 id="Promotion"><a class="docs-heading-anchor" href="#Promotion">Promotion</a><a id="Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion" title="Permalink"></a></h1><p>Promoting a selection or <a href="#ProtoSyn.Mask"><code>Mask</code></a> refers to the act of changing the output selection type. As an example, one could promote the selection <code>rn&quot;ALA&quot;</code> (which would output a <a href="#ProtoSyn.Mask"><code>Mask</code></a> of <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances selected) to output a <a href="#ProtoSyn.Mask"><code>Mask</code></a> of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances selected instead. Following the notion that core types in ProtoSyn have an established hierarchical relationship (<a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> &gt; <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> &gt; <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> &gt; <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>), this example type of promotion would be a <em>downwards</em> promotion. The opposite case would be an <em>upwards</em> promotion, such as promoting <code>an&quot;CB&quot;</code> to output a <a href="#ProtoSyn.Mask"><code>Mask</code></a> of <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances instead. In such case, an extra parameter is required: an agregating function. Usually, this is either <code>any</code> (i.e.: select residues that contain at least one <em>CB</em> atom - this is the default) or <code>all</code> (i.e: select residues where all atoms are <em>CB</em>).</p><p>We have two options for promotion operations:</p><p><strong>1 |</strong> Promote the underlying <code>AbstractSelection</code>, before applying to an <code>AbstractContainer</code>. This is, in essence, an <code>AbstractSelection</code> type by itself;</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.PromoteSelection" href="#ProtoSyn.PromoteSelection"><code>ProtoSyn.PromoteSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PromoteSelection(sele::AbstractSelection, ::Type{T}, op::Function) where {T &lt;: AbstractContainer}</code></pre><p>A <a href="#ProtoSyn.PromoteSelection"><code>PromoteSelection</code></a> takes an input selection <code>sele</code> and outputs the same result in a different <a href="#ProtoSyn.Mask"><code>Mask</code></a> type, (depending on the operation <code>op</code> requested for <em>upwards</em> promotions). </p><p><strong>State mode</strong></p><p>The selection type of <a href="#ProtoSyn.PromoteSelection"><code>PromoteSelection</code></a> can be either <code>Stateless</code> or <code>Stateful</code>: it will automatically be set to the <code>StateMode</code> of the provided <code>sele</code> on the constructor.</p><p><strong>Selection type</strong></p><p>The selection type of <a href="#ProtoSyn.PromoteSelection"><code>PromoteSelection</code></a> can be any <code>T &lt;: AbstractContainer</code>. When queried for using the <code>selection_type</code> function, will return the selection type of the given <code>sele</code>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This selection does not have a short syntax version. However, the <code>promote</code> function is used to return <a href="#ProtoSyn.PromoteSelection"><code>PromoteSelection</code></a> instances with a more user friendly syntax.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = PromoteSelection(rn&quot;ALA&quot;, Segment, all)
PromoteSelection ❯ From Residue to Segment
 └── FieldSelection › Residue.name = ALA</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/promotion.jl#L4-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.promote-Union{Tuple{T2}, Tuple{AbstractSelection, Type{T2}, Function}} where T2&lt;:ProtoSyn.AbstractContainer" href="#ProtoSyn.promote-Union{Tuple{T2}, Tuple{AbstractSelection, Type{T2}, Function}} where T2&lt;:ProtoSyn.AbstractContainer"><code>ProtoSyn.promote</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote(sele::AbstractSelection, ::Type{T2}, [aggregator::Function = any]) where {T2 &lt;: AbstractContainer}</code></pre><p>Return a <a href="#ProtoSyn.PromoteSelection"><code>PromoteSelection</code></a> instance for selection <code>sele</code>, promoting to the requested type <code>T2 &lt;: AbstractContainer</code>. If this is an <em>upwards</em> promotion, use the given <code>aggregator</code> function (default: <code>any</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.promote(rn&quot;ALA&quot;, Atom)
PromoteSelection ❯ From Residue to Atom
 └── FieldSelection › Residue.name = ALA</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/promotion.jl#L62-L75">source</a></section></article><p><strong>2 |</strong> Promote an already calculated <a href="#ProtoSyn.Mask"><code>Mask</code></a> instance (by applying the selection - see <a href="#Applying-selections">Applying selections</a> section).</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.promote-Union{Tuple{T2}, Tuple{T1}, Tuple{Mask{T1}, Type{T2}, ProtoSyn.AbstractContainer, Function}} where {T1&lt;:ProtoSyn.AbstractContainer, T2&lt;:ProtoSyn.AbstractContainer}" href="#ProtoSyn.promote-Union{Tuple{T2}, Tuple{T1}, Tuple{Mask{T1}, Type{T2}, ProtoSyn.AbstractContainer, Function}} where {T1&lt;:ProtoSyn.AbstractContainer, T2&lt;:ProtoSyn.AbstractContainer}"><code>ProtoSyn.promote</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote(mask::Mask{T1}, ::Type{T2}, container::AbstractContainer, f::Function = any)::Mask where {T1 &lt;: AbstractContainer, T2 &lt;: AbstractContainer}</code></pre><p>Cast a <a href="#ProtoSyn.Mask"><code>Mask</code></a> of type <code>T1</code> to be of type <code>T2</code>, in the context of the given <code>container</code>. If casting to a higher ranking type (<em>upwards</em> promotion - Ex. Atom -&gt; Residue), a function <code>f</code> establishes the grouping operation (<code>any</code> occurrence (by default) or <code>all</code> occurrences of lower ranking type must be <code>true</code> to set the higher ranking entry to <code>true</code>.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = an&quot;CB&quot;(pose);

julia&gt; ProtoSyn.promote(m1, Residue, pose.graph);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/promotion.jl#L129-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.promote-Union{Tuple{T2}, Tuple{T1}, Tuple{Mask{T1}, Mask{T2}, ProtoSyn.AbstractContainer}} where {T1, T2}" href="#ProtoSyn.promote-Union{Tuple{T2}, Tuple{T1}, Tuple{Mask{T1}, Mask{T2}, ProtoSyn.AbstractContainer}} where {T1, T2}"><code>ProtoSyn.promote</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote(m1::Mask{T1}, m2::Mask{T2}, container::AbstractContainer) where {T1, T2}</code></pre><p>Promote one of the 2 given <code>Masks</code> (<code>m1</code> and <code>m2</code>) to the lowest ranking common type (Ex. <code>promote(m1::Mask{Residue}, m2::Mask{Atom}) =&gt; (Mask{Atom}, Mask{Atom)</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = an&quot;CB&quot;(pose);

julia&gt; m2 = rn&quot;LEU&quot;(pose);

julia&gt; ProtoSyn.promote(m1, m2, pose.graph);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/promotion.jl#L99-L114">source</a></section></article><h1 id="Combining-selections"><a class="docs-heading-anchor" href="#Combining-selections">Combining selections</a><a id="Combining-selections-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-selections" title="Permalink"></a></h1><p>Two selections can be combined using logical operators (such as <code>or</code> and <code>and</code>), returning a <a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a>. The resulting selection&#39;s <code>StateMode</code> and selection type depend on the two merged selections.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.BinarySelection" href="#ProtoSyn.BinarySelection"><code>ProtoSyn.BinarySelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BinarySelection(op::Function, left::L, right::R) where {L &lt;: AbstractSelection, R &lt;: AbstractSelection}</code></pre><p>A <a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a> merges two selections using different operators <code>op</code>, such as <code>and</code> and <code>or</code>. Return a new <a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a> that combines both <code>left</code> and <code>right</code> AbstractSelections, using the defined operator <code>op</code>.</p><p><strong>State mode</strong></p><p>If the defined selections have the same state mode, the resulting mask will be of that state mode. If the defined selections have different state modes (Ex: <code>Stateless</code> and <code>Stateful</code>) the resulting selection will have a <code>Stateful</code> state mode.</p><p><strong>Selection type</strong></p><p>If the defined have the same selection type, the resulting mask will be of that type. If the defined selections have different selection types (Ex: <code>Atom</code> and <code>Residue</code>), the resulting mask will be promoted to the lowest ranking type (Ex: <code>Atom</code>).</p><p><strong>See also</strong></p><p><a href="#Promotion">Promotion</a></p><p><strong>Short syntax</strong></p><ul><li>... &amp; ...</li><li>... | ...</li></ul><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p><a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a> instances are <em>left-dominant</em>, meaning that a grouping of logical operators such as <code>rn&quot;ALA&quot; &amp; rn&quot;LEU&quot; | an&quot;CA&quot;</code> will first resolve the <code>rn&quot;ALA&quot; &amp; rn&quot;LEU&quot;</code> part (which should return an all-false <a href="#ProtoSyn.Mask"><code>Mask</code></a>) and only then combine this <a href="#ProtoSyn.Mask"><code>Mask</code></a> with the <code>| an&quot;CA&quot;</code> <a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a>, thus essentially selecting only the <em>CA</em> atoms of the <code>AbstractContainer</code> its applied to.</p><p>However, <strong>selections respect to parenthesis grouping</strong>, meaning <code>rn&quot;ALA&quot; &amp; (rn&quot;LEU&quot; | an&quot;CA&quot;)</code> will first resolve <code>rn&quot;LEU&quot; | an&quot;CA&quot;</code> (which should return a <a href="#ProtoSyn.Mask"><code>Mask</code></a> selecting all atoms of all <em>LEU</em> residues plus the <em>CA</em> atoms of all other residues) and only then combine this <a href="#ProtoSyn.Mask"><code>Mask</code></a> with the <code>rn&quot;ALA&quot; &amp;</code> <a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a>, thus essentially selecting only the <em>CA</em> atoms of any <em>ALA</em> residues of the <code>AbstractContainer</code> its applied to.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sele = BinarySelection(&amp;, rn&quot;ALA&quot;, an&quot;CA&quot;)
BinarySelection ❯  &amp; &quot;and&quot; (Atom)
 ├── FieldSelection › Residue.name = ALA
 └── FieldSelection › Atom.name = CA

julia&gt; rn&quot;ALA&quot; &amp; an&quot;CA&quot;
BinarySelection ❯  &amp; &quot;and&quot; (Atom)
 ├── FieldSelection › Residue.name = ALA
 └── FieldSelection › Atom.name = CA</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/binary.jl#L4-L61">source</a></section></article><p><img src="../../../../assets/ProtoSyn-select-5.png" alt="ProtoSyn selections5"/></p><p><strong>Figure 5 |</strong> An example of a possible combination of <code>AbstractSelection</code> types, in ProtoSyn. In this example, two <a href="#ProtoSyn.FieldSelection"><code>FieldSelection</code></a> instances (<code>an&quot;CA&quot;</code> and <code>rn&quot;ALA&quot;</code>) are combined using a <a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a>, with operation <code>op</code> being the <code>&amp;</code> (&quot;and&quot;), effectly selecting all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in a given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> who are <code>CA</code> atoms belonging to an <code>ALA</code> residue. This <code>AbstractSelection</code> is further used as input for a <a href="#ProtoSyn.DistanceSelection"><code>DistanceSelection</code></a>, selecting all <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances within 10.0 Å of a <code>CA</code> atom in an <code>ALA</code> residue. Since <a href="#ProtoSyn.FieldSelection"><code>FieldSelection</code></a> instances act directly on a given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> instance (and not on other <code>AbstractSelection</code> instances), these are said to be &quot;leaf selections&quot;, in contrast with &quot;branch selections&quot;. Branch selections act on other <code>AbstractSelection</code> instances. For example, the <a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a> combines two <code>AbstractSelection</code> instances with a given operator <code>op</code>. </p><h1 id="Applying-selections"><a class="docs-heading-anchor" href="#Applying-selections">Applying selections</a><a id="Applying-selections-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-selections" title="Permalink"></a></h1><p>As stated in the <a href="#Masks">Masks</a> section, selections are applied to <code>AbstractContainer</code> instances, selecting all elements of the desired selection type in that container. This is known as <em>resolving</em> the selection. All <code>AbstractSelection</code> instances are actually <em>functors</em>, meaning that selections are callable objects.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rn&quot;ALA&quot;(pose.graph)</code><code class="nohighlight hljs ansi" style="display:block;">ProtoSyn.Mask
 ├── Type: Residue
 ├── Size: (4,)
 ├── Count: 1 / 4
 └── Content: [0, 1, 0, 0]</code></pre><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>When applying <a href="#ProtoSyn.BinarySelection"><code>BinarySelection</code></a> instances, note the need for parenthesis to highlight what is part of the selection, to avoid syntax errors. The same applies to compound selections, such as <a href="#ProtoSyn.DistanceSelection"><code>DistanceSelection</code></a> instances, for example.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; (rn&quot;ALA&quot; &amp; an&quot;CA&quot;)(pose)</code><code class="nohighlight hljs ansi" style="display:block;">ProtoSyn.Mask
 ├── Type: Atom
 ├── Size: (49,)
 ├── Count: 1 / 49
 └── Content: [0, 0, 0, 0, 0, 0, 0, 0, 0, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</code></pre><p>As stated before, <code>Stateful</code> selections require a <a href="../../types/#state-types">State</a> to calculate the selection. Given the syntax used, there are two ways of providing the <a href="../../types/#state-types">State</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; (10:rn&quot;ALA&quot;)(pose.graph)(pose.state)</code><code class="nohighlight hljs ansi" style="display:block;">ProtoSyn.Mask
 ├── Type: Atom
 ├── Size: (49,)
 ├── Count: 49 / 49
 └── Content: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (10:rn&quot;ALA&quot;)(pose.graph, pose.state)</code><code class="nohighlight hljs ansi" style="display:block;">ProtoSyn.Mask
 ├── Type: Atom
 ├── Size: (49,)
 ├── Count: 49 / 49
 └── Content: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</code></pre><p>In such cases, the second syntax (<code>sele(pose.graph, pose.state)</code>) is recomended.</p><p>Specific methods are available to apply selections to <a href="../../types/#pose-types">Pose</a> instances, in particular. In this cases, the methods automatically calls <code>sele(pose.graph, pose.state)</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; (10:rn&quot;ALA&quot;)(pose)</code><code class="nohighlight hljs ansi" style="display:block;">ProtoSyn.Mask
 ├── Type: Atom
 ├── Size: (49,)
 ├── Count: 49 / 49
 └── Content: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rn&quot;ALA&quot;(pose)</code><code class="nohighlight hljs ansi" style="display:block;">ProtoSyn.Mask
 ├── Type: Residue
 ├── Size: (4,)
 ├── Count: 1 / 4
 └── Content: [0, 1, 0, 0]</code></pre><p>Finally, selections (and <a href="#ProtoSyn.Mask"><code>Mask</code></a> instances) can be <em>gathered</em>. This, in essence, means looping over the <em>resolved</em> <a href="#ProtoSyn.Mask"><code>Mask</code></a> and appending the actually selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> or <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> instances to an output <code>Vector</code>. This process can be done in one of two ways:</p><p><strong>1 |</strong> By using the optional flag <code>gather</code> when applying a selection to an <code>AbstractContainer</code> (recommended);</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; an&quot;^C.*$&quot;r(pose, gather = true)</code><code class="nohighlight hljs ansi" style="display:block;">15-element Vector{Atom}:
 Atom{/UNK:1/UNK:1/GLY:1/CA:3}
 Atom{/UNK:1/UNK:1/GLY:1/C:6}
 Atom{/UNK:1/UNK:1/ALA:2/CA:10}
 Atom{/UNK:1/UNK:1/ALA:2/CB:12}
 Atom{/UNK:1/UNK:1/ALA:2/C:16}
 Atom{/UNK:1/UNK:1/MET:3/CA:20}
 Atom{/UNK:1/UNK:1/MET:3/CB:22}
 Atom{/UNK:1/UNK:1/MET:3/CG:25}
 Atom{/UNK:1/UNK:1/MET:3/CE:29}
 Atom{/UNK:1/UNK:1/MET:3/C:33}
 Atom{/UNK:1/UNK:1/GLU:4/CA:37}
 Atom{/UNK:1/UNK:1/GLU:4/CB:39}
 Atom{/UNK:1/UNK:1/GLU:4/CG:42}
 Atom{/UNK:1/UNK:1/GLU:4/CD:45}
 Atom{/UNK:1/UNK:1/GLU:4/C:48}</code></pre><p><strong>2 |</strong> By directly calling the function <a href="#ProtoSyn.gather"><code>gather</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.gather" href="#ProtoSyn.gather"><code>ProtoSyn.gather</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ProtoSyn.gather(mask::Mask{T}, container::AbstractContainer) where {T &lt;: AbstractContainer}</code></pre><p>Gather all instances of type <code>T</code> from <code>container</code> whose relative position is marked as <code>true</code> in the given <code>mask</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.gather(rn&quot;ALA&quot;(pose), pose.graph)
4-element Vector{Residue}:
 Residue{/UNK:1/UNK:1/ALA:5}
 Residue{/UNK:1/UNK:1/ALA:12}
 Residue{/UNK:1/UNK:1/ALA:13}
 Residue{/UNK:1/UNK:1/ALA:20}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Submodules/Selections/selections.jl#L62-L77">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../drivers/drivers-compound/">« Compound Driver</a><a class="docs-footer-nextpage" href="../builder/">Builder »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Tuesday 16 August 2022 14:09">Tuesday 16 August 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
